new file mode 100644
index 0000000..041a96d
--- /dev/null
+++ b/auxdir/x_ac_pmix.m4
@@ -0,0 +1,84 @@
+##*****************************************************************************
+#  AUTHOR:
+#    Artem Polyakov <artpol84@gmail.com>
+#
+#  SYNOPSIS:
+#    X_AC_PMIX
+#
+#  DESCRIPTION:
+#    Determine if the PMIx libraries exists. Derived from "x_ac_hwloc.m4".
+##*****************************************************************************
+
+AC_DEFUN([X_AC_PMIX],
+[
+  _x_ac_pmix_dirs="/usr /usr/local"
+  _x_ac_pmix_libs="lib64 lib"
+
+  AC_ARG_WITH(
+    [pmix],
+    AS_HELP_STRING(--with-pmix=PATH,Specify path to pmix installation),
+    [_x_ac_pmix_dirs="$withval $_x_ac_pmix_dirs"])
+
+  AC_CACHE_CHECK(
+    [for pmix installation],
+    [x_ac_cv_pmix_dir],
+    [
+      for d in $_x_ac_pmix_dirs; do
+        test -d "$d" || continue
+        test -d "$d/include" || continue
+        test -f "$d/include/pmix/pmix_common.h" || continue
+        test -f "$d/include/pmix_server.h" || continue
+        for d1 in $_x_ac_pmix_libs; do
+          test -d "$d/$d1" || continue
+          _x_ac_pmix_cppflags_save="$CPPFLAGS"
+          CPPFLAGS="-I$d/include $CPPFLAGS"
+          _x_ac_pmix_libs_save="$LIBS"
+          LIBS="-L$d/$d1 -lpmix $LIBS"
+          AC_LINK_IFELSE(
+            [AC_LANG_CALL([], PMIx_Get_version)],
+            AS_VAR_SET(x_ac_cv_pmix_dir, $d))
+          CPPFLAGS="$_x_ac_pmix_cppflags_save"
+          LIBS="$_x_ac_pmix_libs_save"
+          test -n "$x_ac_cv_pmix_dir" && break
+        done
+        test -n "$x_ac_cv_pmix_dir" && break
+      done
+    ])
+
+  if test -z "$x_ac_cv_pmix_dir"; then
+    AC_MSG_WARN([unable to locate pmix installation])
+  else
+    AC_CACHE_CHECK(
+      [for pmix library directory],
+      [x_ac_cv_pmix_libdir],
+      [
+        for d1 in $_x_ac_pmix_libs; do
+          d="$x_ac_cv_pmix_dir/$d1"
+          test -d "$d" || continue
+          _x_ac_pmix_cppflags_save="$CPPFLAGS"
+          CPPFLAGS="-I$x_ac_cv_pmix_dir/include $CPPFLAGS"
+          _x_ac_pmix_libs_save="$LIBS"
+          LIBS="-L$d -lpmix $LIBS"
+          AC_LINK_IFELSE(
+            [AC_LANG_CALL([], PMIx_Get_version)],
+            AS_VAR_SET(x_ac_cv_pmix_libdir, $d))
+          CPPFLAGS="$_x_ac_pmix_cppflags_save"
+          LIBS="$_x_ac_pmix_libs_save"
+          test -n "$x_ac_cv_pmix_libdir" && break
+        done
+    ])
+    PMIX_CPPFLAGS="-I$x_ac_cv_pmix_dir/include"
+    if test "$ac_with_rpath" = "yes"; then
+      PMIX_LDFLAGS="-Wl,-rpath -Wl,$x_ac_cv_pmix_libdir -L$x_ac_cv_pmix_libdir"
+    else
+      PMIX_LDFLAGS="-L$x_ac_cv_pmix_libdir"
+    fi
+    PMIX_LIBS="-lpmix"
+    AC_DEFINE(HAVE_PMIX, 1, [Define to 1 if pmix library found])
+  fi
+
+  AC_SUBST(PMIX_LIBS)
+  AC_SUBST(PMIX_CPPFLAGS)
+  AC_SUBST(PMIX_LDFLAGS)
+  AM_CONDITIONAL(HAVE_PMIX, test -n "$x_ac_cv_pmix_dir")
+])
diff --git a/configure.ac b/configure.ac
index 57a4da9..eca6437 100644
--- a/configure.ac
+++ b/configure.ac
@@ -243,6 +243,7 @@ AM_CONDITIONAL(BUILD_HDF5, test "$with_hdf5" = "yes")
 AC_DEFINE([H5_NO_DEPRECATED_SYMBOLS], [1], [Make sure we get the 1.8 HDF5 API])
 
 X_AC_HWLOC
+X_AC_PMIX
 X_AC_FREEIPMI
 X_AC_SLURM_SEMAPHORE
 X_AC_RRDTOOL
@@ -656,6 +657,7 @@ AC_CONFIG_FILES([Makefile
 		 src/plugins/mpi/none/Makefile
 		 src/plugins/mpi/openmpi/Makefile
 		 src/plugins/mpi/pmi2/Makefile
+		 src/plugins/mpi/pmix/Makefile
 		 src/plugins/task/Makefile
 		 src/plugins/task/affinity/Makefile
 		 src/plugins/task/cgroup/Makefile
diff --git a/src/plugins/mpi/Makefile.am b/src/plugins/mpi/Makefile.am
index ea65f7e..6f79127 100644
--- a/src/plugins/mpi/Makefile.am
+++ b/src/plugins/mpi/Makefile.am
@@ -5,4 +5,7 @@ if REAL_BGQ_LOADED
 SUBDIRS = none
 else
 SUBDIRS = mpich1_p4 mpich1_shmem mpichgm mpichmx mvapich none lam openmpi pmi2
+if HAVE_PMIX
+SUBDIRS += pmix
+endif
 endif
diff --git a/src/plugins/mpi/Makefile.in b/src/plugins/mpi/Makefile.in
index e724307..07a66ab 100644
--- a/src/plugins/mpi/Makefile.in
+++ b/src/plugins/mpi/Makefile.in
@@ -187,7 +187,7 @@ am__define_uniq_tagged_files = \
 ETAGS = etags
 CTAGS = ctags
 DIST_SUBDIRS = mpich1_p4 mpich1_shmem mpichgm mpichmx mvapich none lam \
-	openmpi pmi2
+	openmpi pmi2 pmix
 DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
 am__relativize = \
   dir0=`pwd`; \
@@ -462,7 +462,7 @@ target_vendor = @target_vendor@
 top_build_prefix = @top_build_prefix@
 top_builddir = @top_builddir@
 top_srcdir = @top_srcdir@
-@REAL_BGQ_LOADED_FALSE@SUBDIRS = mpich1_p4 mpich1_shmem mpichgm mpichmx mvapich none lam openmpi pmi2
+@REAL_BGQ_LOADED_FALSE@SUBDIRS = mpich1_p4 mpich1_shmem mpichgm mpichmx mvapich none lam openmpi pmi2 pmix
 
 #on a real BGQ do not compile any mpi plugins
 @REAL_BGQ_LOADED_TRUE@SUBDIRS = none
diff --git a/src/plugins/mpi/pmix/Makefile.am b/src/plugins/mpi/pmix/Makefile.am
new file mode 100644
index 0000000..1824c99
--- /dev/null
+++ b/src/plugins/mpi/pmix/Makefile.am
@@ -0,0 +1,22 @@
+# Makefile for mpi/pmix plugin
+
+AUTOMAKE_OPTIONS = foreign
+
+PLUGIN_FLAGS = -module -avoid-version --export-dynamic
+
+AM_CPPFLAGS = -I$(top_srcdir) -I$(top_srcdir)/src/common $(PMIX_CPPFLAGS)
+
+pkglib_LTLIBRARIES = mpi_pmix.la 
+
+# OpenMPI MPI plugin.
+mpi_pmix_la_SOURCES = mpi_pmix.c pmixp_agent.c pmixp_client.c pmixp_coll.c pmixp_nspaces.c pmixp_info.c \
+			pmixp_server.c pmixp_state.c pmixp_io.c pmixp_utils.c pmixp_dmdx.c \
+			pmixp_agent.h pmixp_client.h pmixp_coll.h pmixp_nspaces.h pmixp_info.h \
+			pmixp_server.h pmixp_state.h pmixp_io.h pmixp_utils.h pmixp_common.h pmixp_dmdx.h
+
+mpi_pmix_la_LIBADD = \
+	$(top_builddir)/src/slurmd/common/libslurmd_reverse_tree_math.la $(PMIX_LDFLAGS) $(PMIX_LIBS)
+
+mpi_pmix_la_LDFLAGS = $(SO_LDFLAGS) $(PLUGIN_FLAGS)
+
+
diff --git a/src/plugins/mpi/pmix/TODO b/src/plugins/mpi/pmix/TODO
new file mode 100644
index 0000000..92c429e
--- /dev/null
+++ b/src/plugins/mpi/pmix/TODO
@@ -0,0 +1,5 @@
+The list of things that has to be done in future
+
+1. Retrieve cpusets from SLURM and pass it to the application.
+2. Implement MPI dynamics.
+3. ...
diff --git a/src/plugins/mpi/pmix/mpi_pmix.c b/src/plugins/mpi/pmix/mpi_pmix.c
new file mode 100644
index 0000000..3a98bc3
--- /dev/null
+++ b/src/plugins/mpi/pmix/mpi_pmix.c
@@ -0,0 +1,173 @@
+/*****************************************************************************\
+ **  mpi_pmix.c - Main plugin callbacks for PMIx support in SLURM
+ *****************************************************************************
+ *  Copyright (C) 2014-2015 Artem Polyakov. All rights reserved.
+ *  Copyright (C) 2015      Mellanox Technologies. All rights reserved.
+ *  Written by Artem Y. Polyakov <artpol84@gmail.com, artemp@mellanox.com>.
+ *
+ *  This file is part of SLURM, a resource management program.
+ *  For details, see <http://slurm.schedmd.com/>.
+ *  Please also read the included file: DISCLAIMER.
+ *
+ *  SLURM is free software; you can redistribute it and/or modify it under
+ *  the terms of the GNU General Public License as published by the Free
+ *  Software Foundation; either version 2 of the License, or (at your option)
+ *  any later version.
+ *
+ *  In addition, as a special exception, the copyright holders give permission
+ *  to link the code of portions of this program with the OpenSSL library under
+ *  certain conditions as described in each individual source file, and
+ *  distribute linked combinations including the two. You must obey the GNU
+ *  General Public License in all respects for all of the code used other than
+ *  OpenSSL. If you modify file(s) with this exception, you may extend this
+ *  exception to your version of the file(s), but you are not obligated to do
+ *  so. If you do not wish to do so, delete this exception statement from your
+ *  version.  If you delete this exception statement from all source files in
+ *  the program, then also delete it here.
+ *
+ *  SLURM is distributed in the hope that it will be useful, but WITHOUT ANY
+ *  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+ *  FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
+ *  details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with SLURM; if not, write to the Free Software Foundation, Inc.,
+ *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA.
+ \*****************************************************************************/
+
+#if     HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <fcntl.h>
+#include <signal.h>
+#include <sys/types.h>
+
+#include "pmixp_common.h"
+#include "pmixp_server.h"
+#include "pmixp_debug.h"
+#include "pmixp_agent.h"
+#include "pmixp_info.h"
+
+#include <pmix_server.h>
+#include <pmixp_client.h>
+
+/*
+ * These variables are required by the generic plugin interface.  If they
+ * are not found in the plugin, the plugin loader will ignore it.
+ *
+ * plugin_name - a string giving a human-readable description of the
+ * plugin.  There is no maximum length, but the symbol must refer to
+ * a valid string.
+ *
+ * plugin_type - a string suggesting the type of the plugin or its
+ * applicability to a particular form of data or method of data handling.
+ * If the low-level plugin API is used, the contents of this string are
+ * unimportant and may be anything.  SLURM uses the higher-level plugin
+ * interface which requires this string to be of the form
+ *
+ *      <application>/<method>
+ *
+ * where <application> is a description of the intended application of
+ * the plugin (e.g., "switch" for SLURM switch) and <method> is a description
+ * of how this plugin satisfies that application.  SLURM will only load
+ * a switch plugin if the plugin_type string has a prefix of "switch/".
+ *
+ * plugin_version - an unsigned 32-bit integer giving the version number
+ * of the plugin.  If major and minor revisions are desired, the major
+ * version number may be multiplied by a suitable magnitude constant such
+ * as 100 or 1000.  Various SLURM versions will likely require a certain
+ * minimum version for their plugins as this API matures.
+ */
+const char plugin_name[] = "PMIx plugin";
+const char plugin_type[] = "mpi/pmix";
+const uint32_t plugin_version = SLURM_VERSION_NUMBER;
+
+int p_mpi_hook_slurmstepd_prefork(const stepd_step_rec_t *job, char ***env)
+{
+	int ret;
+	pmixp_debug_hang(0);
+	PMIXP_DEBUG("start");
+
+	if (SLURM_SUCCESS != (ret = pmixp_stepd_init(job, env))) {
+		PMIXP_ERROR("pmixp_stepd_init() failed");
+		goto err_ext;
+	}
+	if (SLURM_SUCCESS != (ret = pmixp_agent_start())) {
+		PMIXP_ERROR("pmixp_agent_start() failed");
+		goto err_ext;
+	}
+	return SLURM_SUCCESS;
+	err_ext:
+	/* Abort the whole job if error! */
+	slurm_kill_job_step(job->jobid, job->stepid, SIGKILL);
+	return ret;
+}
+
+int p_mpi_hook_slurmstepd_task(const mpi_plugin_task_info_t *job, char ***env)
+{
+	pmix_proc_t proc;
+	char **tmp_env = NULL;
+	pmixp_debug_hang(0);
+
+	PMIXP_DEBUG("Patch environment for task %d", job->gtaskid);
+	proc.rank = job->gtaskid;
+	strncpy(proc.nspace, pmixp_info_namespace(), PMIX_MAX_NSLEN);
+	PMIx_server_setup_fork(&proc, &tmp_env);
+	if (NULL != tmp_env) {
+		int i;
+		for (i = 0; NULL != tmp_env[i]; i++) {
+			char *value = strchr(tmp_env[i], '=');
+			if (NULL != value) {
+				*value = '\0';
+				value++;
+				env_array_overwrite(env,
+						(const char *)tmp_env[i],
+						value);
+			}
+			free(tmp_env[i]);
+		}
+		free(tmp_env);
+		tmp_env = NULL;
+	}
+	return SLURM_SUCCESS;
+}
+
+mpi_plugin_client_state_t *p_mpi_hook_client_prelaunch(
+		const mpi_plugin_client_info_t *job, char ***env)
+{
+	char *mapping = NULL;
+	PMIXP_DEBUG("setup process mapping in srun");
+	uint32_t nnodes = job->step_layout->node_cnt;
+	uint32_t ntasks = job->step_layout->task_cnt;
+	uint16_t *task_cnt = job->step_layout->tasks;
+	uint32_t **tids = job->step_layout->tids;
+	mapping = pack_process_mapping(nnodes, ntasks, task_cnt, tids);
+	if (NULL == mapping) {
+		PMIXP_ERROR("Cannot create process mapping");
+		return NULL;
+	}
+	setenvf(env, PMIXP_SLURM_MAPPING_ENV, "%s", mapping);
+	xfree(mapping);
+
+	/* only return NULL on error */
+	return (void *)0xdeadbeef;
+}
+
+int p_mpi_hook_client_single_task_per_node(void)
+{
+	return false;
+}
+
+int p_mpi_hook_client_fini(void)
+{
+	return SLURM_SUCCESS;
+}
+
+int fini(void)
+{
+	PMIXP_DEBUG("%s: call fini()", pmixp_info_hostname());
+	pmixp_agent_stop();
+	pmixp_stepd_finalize();
+	return SLURM_SUCCESS;
+}
diff --git a/src/plugins/mpi/pmix/node_leader/fileops.c b/src/plugins/mpi/pmix/node_leader/fileops.c
new file mode 100644
index 0000000..bb6f546
--- /dev/null
+++ b/src/plugins/mpi/pmix/node_leader/fileops.c
@@ -0,0 +1,251 @@
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <unistd.h>
+#include <string.h>
+#include <stdio.h>
+#include <unistd.h>
+#include <fcntl.h>
+extern int errno;
+#include <errno.h>
+#include <stdlib.h>
+
+
+/* Check the file and return:
+ * - 1 in case it exists
+ * - 0 if not exists
+ * - (-1) in case of unexpected error, like EPERM)
+ * if file exists is_symlink variable is set if the file
+ * is a symlink
+ */
+static int
+_file_exists(char *path)
+{
+    struct stat buf;
+
+    if (stat(path, &buf)) {
+        if (errno == ENOENT) {
+            /* OK. this symlink was removed by somebody else */
+            return 0;
+        }else{
+            fprintf(stderr,"Error while stat'ing symlink %s: %s (%d)\n",
+                    path, strerror(errno), errno);
+            return -1;
+        }
+    }
+    return 1;
+}
+
+static int
+_symlink_exists(char *path)
+{
+    struct stat buf;
+
+    if (lstat(path, &buf)) {
+        return 0;
+    }
+
+    if (!S_ISLNK(buf.st_mode)) {
+        return -1;
+    }
+    return 1;
+}
+
+static int
+_create_locked_cmd(char *path, int cmd)
+{
+    int ret = 0, fd;
+    struct flock flk;
+
+    fd = open(path, O_CREAT | O_RDWR, S_IRUSR | S_IWUSR);
+    if (0 > fd) {
+        fprintf(stderr,"Error opening file %s: %s (%d)\n",
+                path, strerror(errno), errno);
+        return -1;
+    }
+
+
+    flk.l_whence = SEEK_SET;
+    flk.l_start = 0;
+    flk.l_len = 0;
+    flk.l_type = F_WRLCK;
+
+    do{
+        if (0 == (ret = fcntl(fd, cmd, &flk))) {
+            break;
+        } else if (EINTR != errno) {
+            fprintf(stderr,"Error locking file %s: %s (%d)\n",
+                    path, strerror(errno), errno);
+            close(fd);
+            return -errno;
+        }
+    } while(EINTR == errno);
+
+    if (0 == ret)
+        return fd;
+
+    close(fd);
+    return ret;
+}
+
+static int
+_is_locked(char *path)
+{
+    int ret, fd;
+    struct flock flk;
+    memset(&flk, 0, sizeof(flk));
+
+    fd = open(path, O_RDONLY);
+    if (0 > fd) {
+        if (EEXIST == errno) {
+            return 0;
+        } else {
+            fprintf(stderr,"Error opening file %s: %s (%d)\n",
+                    path, strerror(errno), errno);
+            return -1;
+        }
+    }
+
+    do{
+        if (0 == (ret = fcntl(fd, F_GETLK, &flk))) {
+            break;
+        }
+    } while(EINTR == errno);
+
+    if (ret) {
+        fprintf(stderr,"Error getting file lock information for %s: %s (%d)\n",
+                path, strerror(errno), errno);
+        return -1;
+    }
+
+    if (F_WRLCK == flk.l_type && SEEK_SET == flk.l_whence) {
+        return 1;
+    }
+    return 0;
+}
+
+int pmix_leader_is_alive(char *lname)
+{
+    int ret, error;
+    char fname[FILENAME_MAX] = { 0 };
+    char lock_name[FILENAME_MAX] = { 0 };
+
+    ret = _symlink_exists(lname);
+    if (0 > ret) {
+        fprintf(stderr,"Error accessing symlink %s: %d:%s\n",
+                lname, error, strerror(error));
+        return -1;
+    }
+    if (0 > readlink(lname, fname, FILENAME_MAX - 1)) {
+        if (ENOENT == errno) {
+            /* Symlink was removed between _symlink_exists & readlink */
+            return 0;
+        } else {
+            fprintf(stderr,"Error reading symlink %s: %d:%s\n",
+                    lname, error, strerror(error));
+            return -1;
+        }
+    }
+
+    snprintf(lock_name, FILENAME_MAX - 1, "%s.lock",fname);
+    ret = _file_exists(lock_name);
+    /* In case of fatal error (ret < 0) or file abscense */
+    if (0 >= ret)
+        return ret;
+    return _is_locked(lock_name);
+}
+
+void pmix_remove_leader_symlink(char *path)
+{
+    int ret, is_symlink;
+
+    /* Check prior to go further */
+    ret = _symlink_exists(path);
+    if (0 > ret) {
+        fprintf(stderr,"FATAL error\n");
+        exit(1);
+    }
+    if (0 == ret) {
+        /* File was already deleted. Nothing to do */
+        return;
+    }
+
+    char lockname[FILENAME_MAX];
+    sprintf(lockname,"%s.lock", path);
+    int fd = pmix_create_locked_wait(lockname);
+
+    /* Check prior to go further */
+    ret = _symlink_exists(path);
+    if (0 > ret) {
+        fprintf(stderr,"FATAL error\n");
+        exit(1);
+    }
+    if (0 == ret) {
+        /* File was already deleted. Nothing to do */
+        goto exit;
+    }
+
+    if (pmix_leader_is_alive(path)) {
+        /* Somebody already took care about this */
+        goto exit;
+    }
+
+    if (unlink(path)) {
+        if (ENOENT != errno) {
+            fprintf(stderr, "unlink(%s): %s", path, strerror(errno));
+            exit(1);
+        }
+    }
+
+exit:
+    close(fd);
+}
+
+int pmix_create_locked(char *path)
+{
+    return _create_locked_cmd(path, F_SETLK);
+}
+
+int pmix_create_locked_wait(char *path)
+{
+    return _create_locked_cmd(path, F_SETLKW);
+}
+
+
+#if 0
+
+#define FPREFIX "test"
+
+int main(int argc, char **argv)
+{
+    char lockfile[FILENAME_MAX], basefile[FILENAME_MAX];
+    if (2 > argc) {
+        fprintf(stderr, "Not enough parameters\n");
+        exit(0);
+    }
+
+    sprintf(basefile, FPREFIX ".%s", argv[1]);
+    sprintf(lockfile,"%s.lock",basefile);
+    if (0 > _create_locked(lockfile)) {
+        fprintf(stderr, "Cannot create personal lock file %s\n", basefile);
+        exit(0);
+    }
+
+    int fd = open(basefile,O_CREAT | O_RDWR, S_IRUSR | S_IWUSR);
+    if (fd < 0) {
+        fprintf(stderr,"Cannot create basefile\n");
+        exit(0);
+    }
+
+    while(1) {
+        if (!pmix_leader_is_alive(FPREFIX)) {
+            pmix_remove_leader_symlink(FPREFIX);
+            if (!symlink(basefile, FPREFIX)) {
+                while(1) {
+                    sleep(1);
+                }
+            }
+        }
+        sleep(1);
+    }
+}
+#endif
diff --git a/src/plugins/mpi/pmix/node_leader/fileops.h b/src/plugins/mpi/pmix/node_leader/fileops.h
new file mode 100644
index 0000000..adcaff4
--- /dev/null
+++ b/src/plugins/mpi/pmix/node_leader/fileops.h
@@ -0,0 +1,9 @@
+#ifndef FILEOPS_H
+#define FILEOPS_H
+
+int pmix_leader_is_alive(char *lname);
+void pmix_remove_leader_symlink(char *path);
+int pmix_create_locked(char *path);
+int pmix_create_locked_wait(char *path);
+
+#endif /* FILEOPS_H */
diff --git a/src/plugins/mpi/pmix/node_leader/ln_leader.c b/src/plugins/mpi/pmix/node_leader/ln_leader.c
new file mode 100644
index 0000000..5118b73
--- /dev/null
+++ b/src/plugins/mpi/pmix/node_leader/ln_leader.c
@@ -0,0 +1,207 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <errno.h>
+extern int errno;
+#include <string.h>
+#include <dirent.h>
+
+#include <sys/types.h>          /* See NOTES */
+#include <sys/socket.h>
+#include <unistd.h>
+#include <sys/un.h>
+#include <stdlib.h>
+#include <poll.h>
+
+#include "fileops.h"
+
+/* SLURM portability */
+#define SLURM_SUCCESS 0
+#define SLURM_ERROR 1
+/* TODO: fix */
+#define FILENAME_PREFIX "pmix_addr"
+
+typedef struct {
+    int jobid, stepid;
+} local_records_t;
+
+int my_jobid = -1;
+int my_stepid = -1;
+int sfd = -1, lockfd = -1;
+
+char linkname[FILENAME_MAX];
+char usockname[FILENAME_MAX], lockname[FILENAME_MAX];
+
+int prepare_srv_socket(char *path);
+void establish_listen_sock(int jobid, int stepid);
+
+int pid_from_usockname(char *us_name, int jobid);
+int run_discovery(int jobid, int stepid, int *is_leader);
+
+int main(int argc, char **argv)
+{
+    int is_leader;
+    if (argc < 3) {
+        fprintf(stderr,"Not enough arguments\n");
+        exit(0);
+    }
+    my_jobid = atoi(argv[1]);
+    my_stepid = atoi(argv[2]);
+    sprintf(linkname, "%s.%d", FILENAME_PREFIX, my_jobid);
+    sprintf(usockname,"%s.%d", linkname, my_stepid);
+    sprintf(lockname, "%s.lock",usockname);
+
+    if (0 > (lockfd = pmix_create_locked(lockname))) {
+        fprintf(stderr,"Can't create lock file %s\n", lockname);
+        exit(0);
+    }
+
+    sfd = prepare_srv_socket(usockname);
+
+    int i = 0;
+    while(1) {
+        int fd = run_discovery(my_jobid, my_stepid, &is_leader);
+        if (is_leader) {
+            fprintf("Iteration %d. I am the leader\n", i);
+            service_requests(fd);
+        } else {
+            monitor_leader(fd);
+            printf("server closed connection. Repeat resolution\n");
+        }
+        i++;
+    }
+}
+
+int run_discovery(int jobid, int my_stepid, int *is_leader)
+{
+    char lname[FILENAME_MAX], fname[FILENAME_MAX], fname1[FILENAME_MAX];
+
+    *is_leader = 0;
+    if (!pmix_leader_is_alive(linkname)) {
+        pmix_remove_leader_symlink(linkname);
+        if (!symlink(usockname, linkname)) {
+            *is_leader = 1;
+            return sfd;
+        }
+    }
+    return connect_to_server(linkname);
+}
+
+
+int prepare_srv_socket(char *path)
+{
+    static struct sockaddr_un sa;
+    int ret = 0;
+
+    /* Make sure that socket file doesn't exists */
+    if (0 == access(path, F_OK)) {
+        /* remove old file */
+        if (0 != unlink(path)) {
+            /*PMIXP_ERROR_STD*/
+            printf("Cannot delete outdated socket fine: %s",
+                    path);
+            return SLURM_ERROR;
+        }
+    }
+
+    if (strlen(path) >= sizeof(sa.sun_path)) {
+        /*PMIXP_ERROR_STD*/
+        printf("UNIX socket path is too long: %lu, max %lu",
+                (unsigned long)strlen(path),
+                (unsigned long)sizeof(sa.sun_path)-1);
+        return SLURM_ERROR;
+    }
+
+    int fd = socket(AF_UNIX, SOCK_STREAM, 0);
+    if (fd < 0) {
+        /*PMIXP_ERROR_STD*/
+        printf("Cannot create UNIX socket");
+        return SLURM_ERROR;
+    }
+
+    memset(&sa, 0, sizeof(sa));
+    sa.sun_family = AF_UNIX;
+    strcpy(sa.sun_path, path);
+    if (ret = bind(fd, (struct sockaddr*)&sa, SUN_LEN(&sa))) {
+        /*PMIXP_ERROR_STD*/
+        printf("Cannot bind() UNIX socket %s", path);
+        goto err_fd;
+    }
+
+    if ((ret = listen(fd, 64))) {
+        /*PMIXP_ERROR_STD*/
+        printf("Cannot listen(%d, 64) UNIX socket %s", fd, path);
+        goto err_bind;
+    }
+    return fd;
+
+err_bind:
+    unlink(path);
+err_fd:
+    close(fd);
+    return ret;
+}
+
+int connect_to_server(char *path)
+{
+    static struct sockaddr_un sa;
+    memset(&sa, 0, sizeof(sa));
+    sa.sun_family = AF_UNIX;
+    strcpy(sa.sun_path, path);
+
+    int fd = socket(AF_UNIX, SOCK_STREAM, 0);
+    if (fd < 0) {
+        fprintf(stderr,"Cannot create UNIX socket");
+        return -1;
+    }
+
+    if (connect(fd, &sa, SUN_LEN(&sa))) {
+        close(fd);
+        return -1;
+    }
+    local_records_t rec;
+    rec.jobid = my_jobid;
+    rec.stepid = my_stepid;
+    int ret = write(fd, &rec, sizeof(rec));
+    if (sizeof(rec) != ret) {
+        close(fd);
+        return -1;
+    }
+    return fd;
+}
+
+void service_requests(int fd)
+{
+    while(1) {
+        int cfd;
+        if (0 < (cfd = accept(fd, NULL, 0))) {
+            local_records_t rec;
+            int ret = read(cfd, &rec, sizeof(rec));
+            if (ret != sizeof(rec)) {
+                fprintf("%s:%d: read mismatch: %d vs %d\n",
+                        __FILE__, __LINE__, ret, sizeof(rec));
+                exit(0);
+            }
+            fprintf(stderr,"New client connected: jobid=%d, stepid=%d, fd = %d\n",
+                   rec.jobid, rec.stepid, fd);
+        }
+    }
+}
+
+void monitor_leader(int fd)
+{
+    struct pollfd fds;
+    fds.fd = fd;
+    fds.events = 0;
+
+    /* Drop shutdown before the check */
+
+    int rc = poll(&fds, 1, -1);
+    if (rc < 0) {
+        fprintf(stderr,"Get poll error %d: %s", errno, strerror(errno));
+        exit(1);
+    }
+    if (fds.revents != POLLHUP) {
+        fprintf(stderr,"revents = %x", fds.revents);
+    }
+}
diff --git a/src/plugins/mpi/pmix/pmixp_agent.c b/src/plugins/mpi/pmix/pmixp_agent.c
new file mode 100644
index 0000000..f6a3c1c
--- /dev/null
+++ b/src/plugins/mpi/pmix/pmixp_agent.c
@@ -0,0 +1,368 @@
+/*****************************************************************************\
+ **  pmix_agent.c - PMIx agent thread
+ *****************************************************************************
+ *  Copyright (C) 2014-2015 Artem Polyakov. All rights reserved.
+ *  Copyright (C) 2015      Mellanox Technologies. All rights reserved.
+ *  Written by Artem Y. Polyakov <artpol84@gmail.com, artemp@mellanox.com>.
+ *
+ *  This file is part of SLURM, a resource management program.
+ *  For details, see <http://slurm.schedmd.com/>.
+ *  Please also read the included file: DISCLAIMER.
+ *
+ *  SLURM is free software; you can redistribute it and/or modify it under
+ *  the terms of the GNU General Public License as published by the Free
+ *  Software Foundation; either version 2 of the License, or (at your option)
+ *  any later version.
+ *
+ *  In addition, as a special exception, the copyright holders give permission
+ *  to link the code of portions of this program with the OpenSSL library under
+ *  certain conditions as described in each individual source file, and
+ *  distribute linked combinations including the two. You must obey the GNU
+ *  General Public License in all respects for all of the code used other than
+ *  OpenSSL. If you modify file(s) with this exception, you may extend this
+ *  exception to your version of the file(s), but you are not obligated to do
+ *  so. If you do not wish to do so, delete this exception statement from your
+ *  version.  If you delete this exception statement from all source files in
+ *  the program, then also delete it here.
+ *
+ *  SLURM is distributed in the hope that it will be useful, but WITHOUT ANY
+ *  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+ *  FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
+ *  details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with SLURM; if not, write to the Free Software Foundation, Inc.,
+ *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA.
+ \*****************************************************************************/
+
+#include <pthread.h>
+#include <sched.h>
+#include <poll.h>
+#include <arpa/inet.h>
+#include <time.h>
+
+#include "pmixp_common.h"
+#include "pmixp_server.h"
+#include "pmixp_client.h"
+#include "pmixp_state.h"
+#include "pmixp_debug.h"
+#include "pmixp_nspaces.h"
+#include "pmixp_utils.h"
+
+#define MAX_RETRIES 5
+
+static int _agent_is_running = 0;
+static int _timer_is_running = 0;
+static eio_handle_t *_io_handle = NULL;
+
+static int _agent_spawned = 0, _timer_spawned = 0;
+static pthread_t _agent_tid = 0;
+static pthread_t _timer_tid = 0;
+
+struct timer_data_t {
+	int initialized;
+	int work_in, work_out;
+	int stop_in, stop_out;
+};
+static struct timer_data_t timer_data;
+
+static bool _conn_readable(eio_obj_t *obj);
+static int _server_conn_read(eio_obj_t *obj, List objs);
+static int _timer_conn_read(eio_obj_t *obj, List objs);
+static struct io_operations srv_ops = {
+	.readable = &_conn_readable,
+	.handle_read = &_server_conn_read
+};
+
+static struct io_operations to_ops = {
+	.readable = &_conn_readable,
+	.handle_read = &_timer_conn_read
+};
+
+static bool _conn_readable(eio_obj_t *obj)
+{
+	PMIXP_DEBUG("fd = %d", obj->fd);
+	if (obj->shutdown == true) {
+		if (obj->fd != -1) {
+			close(obj->fd);
+			obj->fd = -1;
+		}
+		PMIXP_DEBUG("    false, shutdown");
+		return false;
+	}
+	return true;
+}
+
+static int _server_conn_read(eio_obj_t *obj, List objs)
+{
+	int fd;
+	struct sockaddr addr;
+	socklen_t size = sizeof(addr);
+	int shutdown = 0;
+
+	PMIXP_DEBUG("fd = %d", obj->fd);
+
+	while (1) {
+		/* Return early if fd is not now ready */
+		if (!pmixp_fd_read_ready(obj->fd, &shutdown)) {
+			if (shutdown) {
+				obj->shutdown = true;
+				if (shutdown < 0) {
+					PMIXP_ERROR_NO(shutdown,
+							"sd=%d failure",
+							obj->fd);
+				}
+			}
+			return 0;
+		}
+
+		while ((fd = accept(obj->fd, &addr, &size)) < 0) {
+			if (errno == EINTR)
+				continue;
+			if (errno == EAGAIN) /* No more connections */
+				return 0;
+			if ((errno == ECONNABORTED) || (errno == EWOULDBLOCK)) {
+				return 0;
+			}
+			PMIXP_ERROR_STD("accept()ing connection sd=%d", obj->fd);
+			return 0;
+		}
+
+		PMIXP_DEBUG("accepted connection: sd=%d", fd);
+		/* read command from socket and handle it */
+		pmix_server_new_conn(fd);
+	}
+	return 0;
+}
+
+static int _timer_conn_read(eio_obj_t *obj, List objs)
+{
+	char *tmpbuf[32];
+	int shutdown;
+	PMIXP_DEBUG("Timeout thread, fd = %d", obj->fd);
+
+	/* drain everything from in fd */
+	while (32 == pmixp_read_buf(obj->fd, tmpbuf, 32, &shutdown, false))
+		;
+	if (shutdown) {
+		PMIXP_ERROR("readin from timer fd, shouldn't happen");
+		obj->shutdown = true;
+	}
+
+	/* check direct modex requests */
+	pmixp_dmdx_timeout_cleanup();
+
+	/* check collective statuses */
+	pmixp_state_coll_cleanup();
+
+	return 0;
+}
+
+static void _shutdown_timeout_fds(void);
+
+#define SETUP_FDS(fds) { \
+	fd_set_nonblocking(fds[0]);	\
+	fd_set_close_on_exec(fds[0]);	\
+	fd_set_nonblocking(fds[1]);	\
+	fd_set_close_on_exec(fds[1]);	\
+	}
+
+static int _setup_timeout_fds(void)
+{
+	int fds[2];
+
+	timer_data.work_in = timer_data.work_out = -1;
+	timer_data.stop_in = timer_data.stop_out = -1;
+
+	if (pipe(fds)) {
+		return SLURM_ERROR;
+	}
+	SETUP_FDS(fds);
+	timer_data.work_in = fds[0];
+	timer_data.work_out = fds[1];
+
+	if (pipe(fds)) {
+		_shutdown_timeout_fds();
+		return SLURM_ERROR;
+	}
+	SETUP_FDS(fds);
+	timer_data.stop_in = fds[0];
+	timer_data.stop_out = fds[1];
+
+	timer_data.initialized = 1;
+
+	return SLURM_SUCCESS;
+}
+
+static void _shutdown_timeout_fds(void)
+{
+	if (0 <= timer_data.work_in) {
+		close(timer_data.work_in);
+		timer_data.work_in = -1;
+	}
+	if (0 <= timer_data.work_out) {
+		close(timer_data.work_out);
+		timer_data.work_out = -1;
+	}
+	if (0 <= timer_data.stop_in) {
+		close(timer_data.stop_in);
+		timer_data.stop_in = -1;
+	}
+	if (0 <= timer_data.stop_out) {
+		close(timer_data.stop_out);
+		timer_data.stop_out = -1;
+	}
+}
+
+/*
+ * main loop of agent thread
+ */
+static void *_agent_thread(void *unused)
+{
+	PMIXP_DEBUG("Start agent thread");
+	eio_obj_t *obj;
+	int preval;
+
+	pthread_setcancelstate(PTHREAD_CANCEL_ENABLE, &preval);
+	pthread_setcanceltype(PTHREAD_CANCEL_ASYNCHRONOUS, &preval);
+
+	_io_handle = eio_handle_create(0);
+
+	obj = eio_obj_create(pmixp_info_srv_fd(), &srv_ops, (void *)(-1));
+	eio_new_initial_obj(_io_handle, obj);
+
+	obj = eio_obj_create(timer_data.work_in, &to_ops, (void *)(-1));
+	eio_new_initial_obj(_io_handle, obj);
+
+	pmixp_info_io_set(_io_handle);
+
+	_agent_is_running = 1;
+
+	eio_handle_mainloop(_io_handle);
+
+	PMIXP_DEBUG("agent thread exit");
+	eio_handle_destroy(_io_handle);
+
+	_agent_is_running = 0;
+	return NULL;
+}
+
+static void *_pmix_timer_thread(void *unused)
+{
+	struct pollfd pfds[1];
+	int preval;
+
+	pthread_setcancelstate(PTHREAD_CANCEL_ENABLE, &preval);
+	pthread_setcanceltype(PTHREAD_CANCEL_ASYNCHRONOUS, &preval);
+
+	PMIXP_DEBUG("Start timer thread");
+
+	pfds[0].fd = timer_data.stop_in;
+	pfds[0].events = POLLIN;
+
+	_timer_is_running = 1;
+
+	/* our job is to sleep 1 sec and then trigger
+	 * the timer event in the main loop */
+
+	while (1) {
+		/* during normal operation there should be no
+		 * activity on the stop fd.
+		 * So normally we need to exit by the timeout.
+		 * This forses periodic timer events (once each second) */
+		int ret = poll(pfds, 1, 1000);
+		char c = 1;
+		if (0 < ret) {
+			/* there was an event on stop_fd, exit */
+			break;
+		}
+		/* activate main thread's timer event */
+		write(timer_data.work_out, &c, 1);
+	}
+
+	_timer_is_running = 0;
+
+	return NULL;
+}
+
+int pmixp_agent_start(void)
+{
+	int retries = 0;
+	pthread_attr_t attr;
+
+	_setup_timeout_fds();
+
+	slurm_attr_init(&attr);
+
+	/* start agent thread */
+	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
+	while ((errno = pthread_create(&_agent_tid, &attr, _agent_thread, NULL))) {
+		if (++retries > MAX_RETRIES) {
+			PMIXP_ERROR_STD("pthread_create error"); slurm_attr_destroy(&attr);
+			return SLURM_ERROR;
+		}
+		sleep(1);
+	}
+	_agent_spawned = 1;
+
+	/* wait for the agent thread to initialize */
+	while (!_agent_is_running) {
+		sched_yield();
+	}
+
+	PMIXP_DEBUG("agent thread started: tid = %lu",
+			(unsigned long) _agent_tid);
+
+	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
+	while ((errno = pthread_create(&_timer_tid, &attr, _pmix_timer_thread,
+			NULL))) {
+		if (++retries > MAX_RETRIES) {
+			PMIXP_ERROR_STD("pthread_create error"); slurm_attr_destroy(&attr);
+			return SLURM_ERROR;
+		}
+		sleep(1);
+	}
+	_timer_spawned = 1;
+
+	/* wait for the agent thread to initialize */
+	while (!_timer_is_running) {
+		sched_yield();
+	}
+
+	slurm_attr_destroy(&attr);
+
+	PMIXP_DEBUG("timer thread started: tid = %lu",
+			(unsigned long) _timer_tid);
+
+	return SLURM_SUCCESS;
+}
+
+int pmixp_agent_stop(void)
+{
+	char c = 1;
+	if (_agent_is_running) {
+		eio_signal_shutdown(_io_handle);
+		/* wait for the agent thread to stop */
+		while (_agent_is_running) {
+			sched_yield();
+		}
+	}
+	if (_agent_spawned) {
+		pthread_cancel(_agent_tid);
+	}
+
+	if (timer_data.initialized) {
+		/* cancel timer */
+		write(timer_data.stop_out, &c, 1);
+		while (_timer_is_running) {
+			sched_yield();
+		}
+		/* close timer fds */
+		_shutdown_timeout_fds();
+	}
+
+	if (_timer_spawned) {
+		pthread_cancel(_timer_tid);
+	}
+	return SLURM_SUCCESS;
+}
diff --git a/src/plugins/mpi/pmix/pmixp_agent.h b/src/plugins/mpi/pmix/pmixp_agent.h
new file mode 100644
index 0000000..c57ad38
--- /dev/null
+++ b/src/plugins/mpi/pmix/pmixp_agent.h
@@ -0,0 +1,46 @@
+/*****************************************************************************\
+ **  pmix_agent.h - PMIx agent thread
+ *****************************************************************************
+ *  Copyright (C) 2014-2015 Artem Polyakov. All rights reserved.
+ *  Copyright (C) 2015      Mellanox Technologies. All rights reserved.
+ *  Written by Artem Y. Polyakov <artpol84@gmail.com, artemp@mellanox.com>.
+ *
+ *  This file is part of SLURM, a resource management program.
+ *  For details, see <http://slurm.schedmd.com/>.
+ *  Please also read the included file: DISCLAIMER.
+ *
+ *  SLURM is free software; you can redistribute it and/or modify it under
+ *  the terms of the GNU General Public License as published by the Free
+ *  Software Foundation; either version 2 of the License, or (at your option)
+ *  any later version.
+ *
+ *  In addition, as a special exception, the copyright holders give permission
+ *  to link the code of portions of this program with the OpenSSL library under
+ *  certain conditions as described in each individual source file, and
+ *  distribute linked combinations including the two. You must obey the GNU
+ *  General Public License in all respects for all of the code used other than
+ *  OpenSSL. If you modify file(s) with this exception, you may extend this
+ *  exception to your version of the file(s), but you are not obligated to do
+ *  so. If you do not wish to do so, delete this exception statement from your
+ *  version.  If you delete this exception statement from all source files in
+ *  the program, then also delete it here.
+ *
+ *  SLURM is distributed in the hope that it will be useful, but WITHOUT ANY
+ *  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+ *  FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
+ *  details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with SLURM; if not, write to the Free Software Foundation, Inc.,
+ *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA.
+ \*****************************************************************************/
+
+#ifndef PMIXP_AGENT_H
+#define PMIXP_AGENT_H
+
+#include "pmixp_common.h"
+
+int pmixp_agent_start(void);
+int pmixp_agent_stop(void);
+
+#endif /* PMIXP_AGENT_H */
diff --git a/src/plugins/mpi/pmix/pmixp_client.c b/src/plugins/mpi/pmix/pmixp_client.c
new file mode 100644
index 0000000..6f2773f
--- /dev/null
+++ b/src/plugins/mpi/pmix/pmixp_client.c
@@ -0,0 +1,678 @@
+/*****************************************************************************\
+ **  pmix_client.c - PMIx client communication code
+ *****************************************************************************
+ *  Copyright (C) 2014-2015 Artem Polyakov. All rights reserved.
+ *  Copyright (C) 2015      Mellanox Technologies. All rights reserved.
+ *  Written by Artem Polyakov <artpol84@gmail.com, artemp@mellanox.com>.
+ *
+ *  This file is part of SLURM, a resource management program.
+ *  For details, see <http://slurm.schedmd.com/>.
+ *  Please also read the included file: DISCLAIMER.
+ *
+ *  SLURM is free software; you can redistribute it and/or modify it under
+ *  the terms of the GNU General Public License as published by the Free
+ *  Software Foundation; either version 2 of the License, or (at your option)
+ *  any later version.
+ *
+ *  In addition, as a special exception, the copyright holders give permission
+ *  to link the code of portions of this program with the OpenSSL library under
+ *  certain conditions as described in each individual source file, and
+ *  distribute linked combinations including the two. You must obey the GNU
+ *  General Public License in all respects for all of the code used other than
+ *  OpenSSL. If you modify file(s) with this exception, you may extend this
+ *  exception to your version of the file(s), but you are not obligated to do
+ *  so. If you do not wish to do so, delete this exception statement from your
+ *  version.  If you delete this exception statement from all source files in
+ *  the program, then also delete it here.
+ *
+ *  SLURM is distributed in the hope that it will be useful, but WITHOUT ANY
+ *  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+ *  FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
+ *  details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with SLURM; if not, write to the Free Software Foundation, Inc.,
+ *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA.
+ \*****************************************************************************/
+
+#include "pmixp_common.h"
+#include "pmixp_state.h"
+#include "pmixp_io.h"
+#include "pmixp_nspaces.h"
+#include "pmixp_debug.h"
+#include "pmixp_coll.h"
+#include "pmixp_server.h"
+#include "pmixp_dmdx.h"
+
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <pmix_server.h>
+
+static int client_connected(const pmix_proc_t *proc, void *server_object)
+{
+	/* we don't do anything by now */
+	return PMIX_SUCCESS;
+}
+
+static void op_callbk(pmix_status_t status, void *cbdata)
+{
+	PMIXP_DEBUG("OP CALLBACK CALLED WITH STATUS %d", status);
+}
+
+static void errhandler_reg_callbk(pmix_status_t status, int errhandler_ref,
+		void *cbdata)
+{
+	PMIXP_DEBUG(
+			"ERRHANDLER REGISTRATION CALLBACK CALLED WITH STATUS %d, ref=%d",
+			status, errhandler_ref);
+}
+
+static pmix_status_t client_finalized(const pmix_proc_t *proc,
+		void *server_object, pmix_op_cbfunc_t cbfunc, void *cbdata)
+{
+	/* don'n do anything by now */
+	if (NULL != cbfunc) {
+		cbfunc(PMIX_SUCCESS, cbdata);
+	}
+	return PMIX_SUCCESS;
+}
+
+static pmix_status_t
+abort_fn(const pmix_proc_t *proc, void *server_object, int status,
+		const char msg[], pmix_proc_t procs[], size_t nprocs,
+		pmix_op_cbfunc_t cbfunc, void *cbdata);
+
+static pmix_status_t
+fencenb_fn(const pmix_proc_t procs[], size_t nprocs,
+	   const pmix_info_t info[], size_t ninfo,
+	   char *data, size_t ndata,
+	   pmix_modex_cbfunc_t cbfunc, void *cbdata);
+
+static pmix_status_t
+dmodex_fn(const pmix_proc_t *proc,
+	  const pmix_info_t info[], size_t ninfo,
+		pmix_modex_cbfunc_t cbfunc, void *cbdata);
+
+static pmix_status_t
+publish_fn(const pmix_proc_t *proc,
+	   const pmix_info_t info[], size_t ninfo,
+		pmix_op_cbfunc_t cbfunc, void *cbdata);
+
+static pmix_status_t
+lookup_fn(const pmix_proc_t *proc, char **keys,
+	  const pmix_info_t info[], size_t ninfo,
+	  pmix_lookup_cbfunc_t cbfunc, void *cbdata);
+
+static pmix_status_t
+unpublish_fn(const pmix_proc_t *proc, char **keys,
+	     const pmix_info_t info[], size_t ninfo,
+	     pmix_op_cbfunc_t cbfunc, void *cbdata);
+
+static pmix_status_t
+spawn_fn(const pmix_proc_t *proc,
+	 const pmix_info_t job_info[], size_t ninfo,
+		const pmix_app_t apps[], size_t napps,
+		pmix_spawn_cbfunc_t cbfunc, void *cbdata);
+
+static pmix_status_t
+connect_fn(const pmix_proc_t procs[], size_t nprocs,
+	   const pmix_info_t info[], size_t ninfo,
+	   pmix_op_cbfunc_t cbfunc, void *cbdata);
+
+static pmix_status_t
+disconnect_fn(const pmix_proc_t procs[], size_t nprocs,
+	      const pmix_info_t info[], size_t ninfo,
+	      pmix_op_cbfunc_t cbfunc, void *cbdata);
+
+pmix_server_module_t _slurm_pmix_cb = {
+	client_connected,
+	client_finalized,
+	abort_fn,
+	fencenb_fn,
+	dmodex_fn,
+	publish_fn,
+	lookup_fn,
+	unpublish_fn,
+	spawn_fn,
+	connect_fn,
+	disconnect_fn,
+	NULL,
+	NULL
+};
+
+static void errhandler(pmix_status_t status, pmix_proc_t proc[], size_t nproc,
+		pmix_info_t info[], size_t ninfo);
+
+int pmixp_libpmix_init(void)
+{
+	int rc;
+
+	/* TODO:
+	 * - check what is the proper rights
+	 * - what if the directory already exists?
+	 */
+	if (0 != mkdir(pmixp_info_tmpdir_lib(), 0766)) {
+		PMIXP_ERROR_STD("Cannot create directory \"%s\"",
+				pmixp_info_tmpdir_lib());
+		return errno;
+	}
+	setenv(PMIXP_PMIXLIB_TMPDIR, pmixp_info_tmpdir_lib(), 1);
+
+	/* setup the server library */
+	if (PMIX_SUCCESS != (rc = PMIx_server_init(&_slurm_pmix_cb))) {
+		PMIXP_ERROR_STD("PMIx_server_init failed with error %d\n", rc);
+		return SLURM_ERROR;
+	}
+
+	/* register the errhandler */
+	PMIx_Register_errhandler(NULL, 0, errhandler, errhandler_reg_callbk,
+			NULL);
+
+	return 0;
+}
+
+int pmixp_libpmix_finalize(void)
+{
+	int rc = SLURM_SUCCESS, rc1;
+
+	/* deregister the errhandler */
+	PMIx_Deregister_errhandler(0, op_callbk, NULL);
+
+	if (PMIX_SUCCESS != PMIx_server_finalize()) {
+		rc = SLURM_ERROR;
+	}
+
+	rc1 = pmixp_rmdir_recursively(pmixp_info_tmpdir_lib());
+	if (0 == rc) {
+		/* return only one error :) */
+		rc = rc1;
+	}
+	return rc;
+}
+
+static void errhandler(pmix_status_t status,
+		       pmix_proc_t proc[], size_t nproc,
+		pmix_info_t info[], size_t ninfo)
+{
+	/* TODO: do something more sophisticated here */
+	/* FIXME: use proper specificator for nranges */
+	PMIXP_ERROR_STD("Error handler invoked: status = %d, nranges = %d",
+			status, (int) nproc);
+	slurm_kill_job_step(pmixp_info_jobid(), pmixp_info_stepid(), SIGKILL);
+}
+
+#define PMIXP_ALLOC_KEY(kvp, key_str)				\
+{								\
+	char *key = key_str;					\
+	kvp = (pmix_info_t *)xmalloc(sizeof(pmix_info_t));	\
+	(void)strncpy(kvp->key, key, PMIX_MAX_KEYLEN);		\
+	}
+
+/*
+ * general proc-level attributes
+ */
+static void _general_proc_info(List lresp)
+{
+	pmix_info_t *kvp;
+	/*      TODO: how can we get this information in SLURM?
+	 *      PMIXP_ALLOC_KEY(kvp, PMIX_CPUSET);
+	 *      PMIX_VAL_SET(&kvp->value, string, "");
+	 *      list_append(lresp, kvp);
+	 *      TODO: what should we provide for credentials?
+	 *      #define PMIX_CREDENTIAL            "pmix.cred"
+	 *      TODO: Once spawn will be implemented we'll need to check here
+	 */
+	 PMIXP_ALLOC_KEY(kvp, PMIX_SPAWNED);
+	 PMIX_VAL_SET(&kvp->value, flag, 0);
+	 list_append(lresp, kvp);
+
+	 /*
+	 *       TODO: what is the portable way to get arch string?
+	 *       #define PMIX_ARCH                  "pmix.arch"
+	 */
+}
+
+/*
+ * scratch directory locations for use by applications
+ */
+static void _set_tmpdirs(List lresp)
+{
+	pmix_info_t *kvp;
+	char *p = NULL;
+
+	/* We consider two sources of the tempdir:
+	 * - SLURM's slurm.conf TmpFS option;
+	 * - env var SLURM_PMIX_TMPDIR;
+	 * do we need to do anything else?
+	 */
+	p = pmixp_info_tmpdir_cli();
+	if (NULL == p) {
+		p = PMIXP_TMPDIR_DEFAULT;
+	}
+	PMIXP_ALLOC_KEY(kvp, PMIX_TMPDIR);
+	PMIX_VAL_SET(&kvp->value, string, p);
+	list_append(lresp, kvp);
+	PMIXP_ALLOC_KEY(kvp, PMIX_NSDIR);
+	PMIX_VAL_SET(&kvp->value, string, p);
+	list_append(lresp, kvp);
+	PMIXP_ALLOC_KEY(kvp, PMIX_PROCDIR);
+	PMIX_VAL_SET(&kvp->value, string, p);
+	list_append(lresp, kvp);
+}
+
+/*
+ * information about relative ranks as assigned by the RM
+ */
+static void _set_procdatas(List lresp)
+{
+	pmixp_namespace_t *nsptr = pmixp_nspaces_local();
+	pmix_info_t *kvp, *tkvp;
+	char *p = NULL;
+	int i;
+
+	/* (char*) jobid assigned by scheduler */
+	xstrfmtcat(p, "%d.%d", pmixp_info_jobid(), pmixp_info_stepid());
+	PMIXP_ALLOC_KEY(kvp, PMIX_JOBID);
+	PMIX_VAL_SET(&kvp->value, string, p);
+	xfree(p);
+	list_append(lresp, kvp);
+
+	/* store information about local processes */
+	for (i = 0; i < pmixp_info_tasks(); i++) {
+		List rankinfo;
+		ListIterator it;
+		int count, j, nodeid, localid;
+		char *nodename;
+		pmix_info_t *info;
+
+		rankinfo = list_create(pmixp_xfree_xmalloced);
+
+		PMIXP_ALLOC_KEY(kvp, PMIX_RANK);
+		PMIX_VAL_SET(&kvp->value, int, i);
+		list_append(rankinfo, kvp);
+
+		/* TODO: always use 0 so far. this is not the general case though
+		 * (see SLURM MIMD: man srun, section MULTIPLE PROGRAM CONFIGURATION)
+		 */
+		PMIXP_ALLOC_KEY(kvp, PMIX_APPNUM);
+		PMIX_VAL_SET(&kvp->value, int, 0);
+		list_append(rankinfo, kvp);
+
+		/* TODO: the same as for previous here */
+		PMIXP_ALLOC_KEY(kvp, PMIX_APPLDR);
+		PMIX_VAL_SET(&kvp->value, int, 0);
+		list_append(rankinfo, kvp);
+
+		/* TODO: fix when several apps will appear */
+		PMIXP_ALLOC_KEY(kvp, PMIX_GLOBAL_RANK);
+		PMIX_VAL_SET(&kvp->value, uint32_t, i);
+		list_append(rankinfo, kvp);
+
+		/* TODO: fix when several apps will appear */
+		PMIXP_ALLOC_KEY(kvp, PMIX_APP_RANK);
+		PMIX_VAL_SET(&kvp->value, uint32_t, i);
+		list_append(rankinfo, kvp);
+
+		localid = pmixp_info_taskid2localid(i);
+		/* this rank is local, store local info ab't it! */
+		if (0 <= localid) {
+			PMIXP_ALLOC_KEY(kvp, PMIX_LOCAL_RANK);
+			PMIX_VAL_SET(&kvp->value, uint32_t, localid);
+			list_append(rankinfo, kvp);
+
+			/* TODO: fix when several apps will appear */
+			PMIXP_ALLOC_KEY(kvp, PMIX_NODE_RANK);
+			PMIX_VAL_SET(&kvp->value, uint32_t, localid);
+			list_append(rankinfo, kvp);
+		}
+
+		nodeid = nsptr->task_map[i];
+		nodename = hostlist_nth(nsptr->hl, nodeid);
+		PMIXP_ALLOC_KEY(kvp, PMIX_HOSTNAME);
+		PMIX_VAL_SET(&kvp->value, string, nodename);
+		list_append(rankinfo, kvp);
+		free(nodename);
+		PMIXP_ALLOC_KEY(kvp, PMIX_NODEID);
+		PMIX_VAL_SET(&kvp->value, uint32_t, nodeid);
+		list_append(rankinfo, kvp);
+
+		/* merge rankinfo into one PMIX_PROC_DATA key */
+		count = list_count(rankinfo);
+		PMIXP_ALLOC_KEY(kvp, PMIX_PROC_DATA);
+		kvp->value.type = PMIX_INFO_ARRAY;
+		kvp->value.data.array.size = count;
+		PMIX_INFO_CREATE(info, count);
+		it = list_iterator_create(rankinfo);
+		j = 0;
+		while (NULL != (tkvp = list_next(it))) {
+			/* Just copy all the fields here. We will free original kvp's
+			 * using list_destroy without free'ing their fields so it is
+			 * safe to do so.
+			 */
+			info[j] = *tkvp;
+			j++;
+		}
+		list_destroy(rankinfo);
+
+		kvp->value.data.array.array = (struct pmix_info_t *)info;
+		info = NULL;
+
+		/* put the complex key to the list */
+		list_append(lresp, kvp);
+	}
+}
+
+static void _set_sizeinfo(List lresp)
+{
+	pmix_info_t *kvp;
+	/* size information */
+	PMIXP_ALLOC_KEY(kvp, PMIX_UNIV_SIZE);
+	PMIX_VAL_SET(&kvp->value, uint32_t, pmixp_info_tasks_uni());
+	list_append(lresp, kvp);
+
+	PMIXP_ALLOC_KEY(kvp, PMIX_JOB_SIZE);
+	PMIX_VAL_SET(&kvp->value, uint32_t, pmixp_info_tasks());
+	list_append(lresp, kvp);
+
+	PMIXP_ALLOC_KEY(kvp, PMIX_LOCAL_SIZE);
+	PMIX_VAL_SET(&kvp->value, uint32_t, pmixp_info_tasks_loc());
+	list_append(lresp, kvp);
+
+	/* TODO: fix it in future */
+	PMIXP_ALLOC_KEY(kvp, PMIX_NODE_SIZE);
+	PMIX_VAL_SET(&kvp->value, uint32_t, pmixp_info_tasks_loc());
+	list_append(lresp, kvp);
+
+	PMIXP_ALLOC_KEY(kvp, PMIX_MAX_PROCS);
+	PMIX_VAL_SET(&kvp->value, uint32_t, pmixp_info_tasks_uni());
+	list_append(lresp, kvp);
+
+}
+
+static int _set_mapsinfo(List lresp)
+{
+	pmix_info_t *kvp;
+	char *regexp, *input;
+	pmixp_namespace_t *nsptr = pmixp_nspaces_local();
+	hostlist_t hl = nsptr->hl;
+	int rc, i, j;
+	int count = hostlist_count(hl);
+
+	input = hostlist_deranged_string_malloc(hl);
+	rc = PMIx_generate_regex(input, &regexp);
+	free(input);
+	if (PMIX_SUCCESS != rc) {
+		return SLURM_ERROR;
+	}
+	PMIXP_ALLOC_KEY(kvp, PMIX_NODE_MAP);
+	PMIX_VAL_SET(&kvp->value, string, regexp);
+	regexp = NULL;
+	list_append(lresp, kvp);
+
+	input = NULL;
+	for (i = 0; i < count; i++) {
+		/* for each node - run through all tasks and
+		 * record taskid's that reside on this node
+		 */
+		int first = 1;
+		for (j = 0; j < nsptr->ntasks; j++) {
+			if (nsptr->task_map[j] == i) {
+				if (first) {
+					first = 0;
+				} else {
+					xstrfmtcat(input, ",");
+				}
+				xstrfmtcat(input, "%u", j);
+			}
+		}
+		if (i < (count - 1)) {
+			xstrfmtcat(input, ";");
+		}
+	}
+	rc = PMIx_generate_ppn(input, &regexp);
+	xfree(input);
+	if (PMIX_SUCCESS != rc) {
+		return SLURM_ERROR;
+	}
+
+	PMIXP_ALLOC_KEY(kvp, PMIX_PROC_MAP);
+	PMIX_VAL_SET(&kvp->value, string, regexp);
+	regexp = NULL;
+	list_append(lresp, kvp);
+
+	PMIXP_ALLOC_KEY(kvp, PMIX_ANL_MAP);
+	PMIX_VAL_SET(&kvp->value, string, pmixp_info_task_map());
+	regexp = NULL;
+	list_append(lresp, kvp);
+
+	return SLURM_SUCCESS;
+}
+
+static void _set_localinfo(List lresp)
+{
+	pmix_info_t *kvp;
+	uint32_t tmp;
+	char *p = NULL;
+	int i;
+
+	xstrfmtcat(p, "%u", pmixp_info_taskid(0));
+	tmp = pmixp_info_taskid(0);
+	for (i = 1; i < pmixp_info_tasks_loc(); i++) {
+		uint32_t rank = pmixp_info_taskid(i);
+		xstrfmtcat(p, ",%u", rank);
+		if (tmp > rank) {
+			tmp = rank;
+		}
+	}
+
+	PMIXP_ALLOC_KEY(kvp, PMIX_LOCAL_PEERS);
+	PMIX_VAL_SET(&kvp->value, string, p);
+	xfree(p);
+	list_append(lresp, kvp);
+
+	PMIXP_ALLOC_KEY(kvp, PMIX_LOCALLDR);
+	PMIX_VAL_SET(&kvp->value, uint32_t, tmp);
+	list_append(lresp, kvp);
+}
+
+typedef struct {
+	volatile int active;
+} _register_caddy_t;
+
+static void _release_cb(pmix_status_t status, void *cbdata)
+{
+	(void)status;
+	_register_caddy_t *caddy = (_register_caddy_t *)cbdata;
+	caddy->active = 0;
+}
+
+int pmixp_libpmix_job_set(void)
+{
+	List lresp;
+	pmix_info_t *info;
+	int ninfo;
+	ListIterator it;
+	pmix_info_t *kvp;
+
+	int i, rc;
+	uid_t uid = getuid();
+	gid_t gid = getgid();
+	_register_caddy_t register_caddy;
+
+	pmixp_debug_hang(0);
+
+	/* Use list to safely expand/reduce key-value pairs. */
+	lresp = list_create(pmixp_xfree_xmalloced);
+
+	_general_proc_info(lresp);
+
+	_set_tmpdirs(lresp);
+
+	_set_procdatas(lresp);
+
+	_set_sizeinfo(lresp);
+
+	if (SLURM_SUCCESS != _set_mapsinfo(lresp)) {
+		list_destroy(lresp);
+		PMIXP_ERROR("Can't build nodemap");
+		return SLURM_ERROR;
+	}
+
+	_set_localinfo(lresp);
+
+	ninfo = list_count(lresp);
+	PMIX_INFO_CREATE(info, ninfo);
+	it = list_iterator_create(lresp);
+	i = 0;
+	while (NULL != (kvp = list_next(it))) {
+		info[i] = *kvp;
+		i++;
+	}
+	list_destroy(lresp);
+
+	register_caddy.active = 1;
+	rc = PMIx_server_register_nspace(pmixp_info_namespace(),
+			pmixp_info_tasks_loc(), info, ninfo, _release_cb,
+			&register_caddy);
+	if (PMIX_SUCCESS == rc) {
+		while (register_caddy.active) {
+			struct timespec ts;
+			ts.tv_sec = 0;
+			ts.tv_nsec = 100;
+			nanosleep(&ts, NULL);
+		}
+	}
+	PMIX_INFO_FREE(info, ninfo);
+
+	if (PMIX_SUCCESS != rc) {
+		PMIXP_ERROR(
+				"Cannot register namespace %s, nlocalproc=%d, " "ninfo = %d",
+				pmixp_info_namespace(), pmixp_info_tasks_loc(),
+				ninfo);
+		return SLURM_ERROR;
+	}
+
+	PMIXP_DEBUG("task initialization");
+	for (i = 0; i < pmixp_info_tasks_loc(); i++) {
+		pmix_proc_t proc;
+		register_caddy.active = 1;
+		strncpy(proc.nspace, pmixp_info_namespace(), PMIX_MAX_NSLEN);
+		proc.rank = pmixp_info_taskid(i);
+		rc = PMIx_server_register_client(&proc, uid, gid, NULL,
+				_release_cb, &register_caddy);
+		if (PMIX_SUCCESS == rc) {
+			while (register_caddy.active) {
+				struct timespec ts;
+				ts.tv_sec = 0;
+				ts.tv_nsec = 100;
+				nanosleep(&ts, NULL);
+			}
+		}
+		if (PMIX_SUCCESS != rc) {
+			PMIXP_ERROR(
+					"Cannot register client %d(%d) in namespace %s",
+					pmixp_info_taskid(i), i,
+					pmixp_info_namespace());
+			return SLURM_ERROR;
+		}
+	}
+	return SLURM_SUCCESS;
+}
+
+static pmix_status_t abort_fn(const pmix_proc_t *proc, void *server_object,
+			      int status, const char msg[], pmix_proc_t procs[],
+			      size_t nprocs, pmix_op_cbfunc_t cbfunc, void *cbdata)
+{
+	/* Just kill this stepid for now. Think what we can do for FT here? */
+	PMIXP_DEBUG("called: status = %d, msg = %s", status, msg);
+	slurm_kill_job_step(pmixp_info_jobid(), pmixp_info_stepid(), SIGKILL);
+
+	if (NULL != cbfunc) {
+		cbfunc(PMIX_SUCCESS, cbdata);
+	}
+	return PMIX_SUCCESS;
+}
+
+pmix_status_t fencenb_fn(const pmix_proc_t procs[], size_t nprocs,
+			 const pmix_info_t info[], size_t ninfo,
+			 char *data, size_t ndata,
+			 pmix_modex_cbfunc_t cbfunc, void *cbdata)
+{
+	PMIXP_DEBUG("called");
+	pmixp_coll_t *coll;
+	pmixp_coll_type_t type = PMIXP_COLL_TYPE_FENCE;
+	pmix_status_t status = PMIX_SUCCESS;
+
+	pmixp_debug_hang(0);
+
+	coll = pmixp_state_coll_get(type, procs, nprocs);
+	pmixp_coll_set_callback(coll, cbfunc, cbdata);
+	if (SLURM_SUCCESS != pmixp_coll_contrib_local(coll, data, ndata)) {
+		goto error;
+	}
+	return PMIX_SUCCESS;
+      error:
+	cbfunc(status, NULL, 0, cbdata, NULL, NULL);
+	return status;
+}
+
+static pmix_status_t dmodex_fn(const pmix_proc_t *proc,
+		const pmix_info_t info[], size_t ninfo,
+		pmix_modex_cbfunc_t cbfunc, void *cbdata)
+{
+	int rc;
+	PMIXP_DEBUG("called");
+
+	rc = pmixp_dmdx_get(proc->nspace, proc->rank, cbfunc, cbdata);
+
+	return (SLURM_SUCCESS == rc) ? PMIX_SUCCESS : PMIX_ERROR;
+}
+
+static pmix_status_t publish_fn(const pmix_proc_t *proc,
+		const pmix_info_t info[], size_t ninfo, pmix_op_cbfunc_t cbfunc,
+		void *cbdata)
+{
+	PMIXP_DEBUG("called");
+	return PMIX_ERR_NOT_IMPLEMENTED;
+}
+
+static pmix_status_t lookup_fn(const pmix_proc_t *proc, char **keys,
+		const pmix_info_t info[], size_t ninfo,
+		pmix_lookup_cbfunc_t cbfunc, void *cbdata)
+{
+	PMIXP_DEBUG("called");
+	return PMIX_ERR_NOT_IMPLEMENTED;
+}
+
+static pmix_status_t unpublish_fn(const pmix_proc_t *proc, char **keys,
+		const pmix_info_t info[], size_t ninfo, pmix_op_cbfunc_t cbfunc,
+		void *cbdata)
+{
+	PMIXP_DEBUG("called");
+	return PMIX_ERR_NOT_IMPLEMENTED;
+}
+
+static pmix_status_t spawn_fn(const pmix_proc_t *proc,
+		const pmix_info_t job_info[], size_t ninfo,
+		const pmix_app_t apps[], size_t napps,
+		pmix_spawn_cbfunc_t cbfunc, void *cbdata)
+{
+	PMIXP_DEBUG("called");
+	return PMIX_ERR_NOT_IMPLEMENTED;
+}
+
+static pmix_status_t connect_fn(const pmix_proc_t procs[], size_t nprocs,
+		const pmix_info_t info[], size_t ninfo, pmix_op_cbfunc_t cbfunc,
+		void *cbdata)
+{
+	PMIXP_DEBUG("called");
+	return PMIX_ERR_NOT_IMPLEMENTED;
+}
+
+static pmix_status_t disconnect_fn(const pmix_proc_t procs[], size_t nprocs,
+		const pmix_info_t info[], size_t ninfo, pmix_op_cbfunc_t cbfunc,
+		void *cbdata)
+{
+	PMIXP_DEBUG("called");
+	return PMIX_ERR_NOT_IMPLEMENTED;
+}
diff --git a/src/plugins/mpi/pmix/pmixp_client.h b/src/plugins/mpi/pmix/pmixp_client.h
new file mode 100644
index 0000000..84c77a0
--- /dev/null
+++ b/src/plugins/mpi/pmix/pmixp_client.h
@@ -0,0 +1,52 @@
+/*****************************************************************************\
+ **  pmix_client.h - PMIx client communication code
+ *****************************************************************************
+ *  Copyright (C) 2014-2015 Artem Polyakov. All rights reserved.
+ *  Copyright (C) 2015      Mellanox Technologies. All rights reserved.
+ *  Written by Artem Polyakov <artpol84@gmail.com, artemp@mellanox.com>.
+ *
+ *  This file is part of SLURM, a resource management program.
+ *  For details, see <http://slurm.schedmd.com/>.
+ *  Please also read the included file: DISCLAIMER.
+ *
+ *  SLURM is free software; you can redistribute it and/or modify it under
+ *  the terms of the GNU General Public License as published by the Free
+ *  Software Foundation; either version 2 of the License, or (at your option)
+ *  any later version.
+ *
+ *  In addition, as a special exception, the copyright holders give permission
+ *  to link the code of portions of this program with the OpenSSL library under
+ *  certain conditions as described in each individual source file, and
+ *  distribute linked combinations including the two. You must obey the GNU
+ *  General Public License in all respects for all of the code used other than
+ *  OpenSSL. If you modify file(s) with this exception, you may extend this
+ *  exception to your version of the file(s), but you are not obligated to do
+ *  so. If you do not wish to do so, delete this exception statement from your
+ *  version.  If you delete this exception statement from all source files in
+ *  the program, then also delete it here.
+ *
+ *  SLURM is distributed in the hope that it will be useful, but WITHOUT ANY
+ *  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+ *  FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
+ *  details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with SLURM; if not, write to the Free Software Foundation, Inc.,
+ *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA.
+ \*****************************************************************************/
+
+#ifndef PMIXP_CLIENT_H
+#define PMIXP_CLIENT_H
+
+#include "pmixp_common.h"
+
+extern pmix_server_module_t _slurm_pmix_callbacks;
+
+int pmixp_libpmix_init(void);
+int pmixp_libpmix_finalize(void);
+int pmixp_libpmix_job_set(void);
+void pmix_libpmix_task_set(int rank, char ***env);
+
+void pmix_client_new_conn(int fd);
+
+#endif /* PMIXP_CLIENT_H */
diff --git a/src/plugins/mpi/pmix/pmixp_coll.c b/src/plugins/mpi/pmix/pmixp_coll.c
new file mode 100644
index 0000000..097d7fc
--- /dev/null
+++ b/src/plugins/mpi/pmix/pmixp_coll.c
@@ -0,0 +1,601 @@
+/*****************************************************************************\
+ **  pmix_coll.c - PMIx collective primitives
+ *****************************************************************************
+ *  Copyright (C) 2014-2015 Artem Polyakov. All rights reserved.
+ *  Copyright (C) 2015      Mellanox Technologies. All rights reserved.
+ *  Written by Artem Polyakov <artpol84@gmail.com, artemp@mellanox.com>.
+ *
+ *  This file is part of SLURM, a resource management program.
+ *  For details, see <http://slurm.schedmd.com/>.
+ *  Please also read the included file: DISCLAIMER.
+ *
+ *  SLURM is free software; you can redistribute it and/or modify it under
+ *  the terms of the GNU General Public License as published by the Free
+ *  Software Foundation; either version 2 of the License, or (at your option)
+ *  any later version.
+ *
+ *  In addition, as a special exception, the copyright holders give permission
+ *  to link the code of portions of this program with the OpenSSL library under
+ *  certain conditions as described in each individual source file, and
+ *  distribute linked combinations including the two. You must obey the GNU
+ *  General Public License in all respects for all of the code used other than
+ *  OpenSSL. If you modify file(s) with this exception, you may extend this
+ *  exception to your version of the file(s), but you are not obligated to do
+ *  so. If you do not wish to do so, delete this exception statement from your
+ *  version.  If you delete this exception statement from all source files in
+ *  the program, then also delete it here.
+ *
+ *  SLURM is distributed in the hope that it will be useful, but WITHOUT ANY
+ *  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+ *  FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
+ *  details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with SLURM; if not, write to the Free Software Foundation, Inc.,
+ *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA.
+ \*****************************************************************************/
+
+#include "pmixp_common.h"
+#include "src/slurmd/common/reverse_tree_math.h"
+#include "src/common/slurm_protocol_api.h"
+#include "pmixp_coll.h"
+#include "pmixp_nspaces.h"
+#include "pmixp_server.h"
+
+static void _progress_fan_in(pmixp_coll_t *coll);
+static void _progres_fan_out(pmixp_coll_t *coll, Buf buf);
+
+static int _hostset_from_ranges(const pmix_proc_t *procs, size_t nprocs,
+		hostlist_t *hl_out)
+{
+	int i;
+	hostlist_t hl = hostlist_create("");
+	pmixp_namespace_t *nsptr = NULL;
+	for (i = 0; i < nprocs; i++) {
+		char *node = NULL;
+		hostlist_t tmp;
+		nsptr = pmixp_nspaces_find(procs[i].nspace);
+		if (NULL == nsptr) {
+			goto err_exit;
+		}
+		if (procs[i].rank == PMIX_RANK_WILDCARD) {
+			tmp = hostlist_copy(nsptr->hl);
+		} else {
+			tmp = pmixp_nspace_rankhosts(nsptr, &procs[i].rank, 1);
+		}
+		while (NULL != (node = hostlist_pop(tmp))) {
+			hostlist_push(hl, node);
+			free(node);
+		}
+		hostlist_destroy(tmp);
+	}
+	hostlist_uniq(hl);
+	*hl_out = hl;
+	return SLURM_SUCCESS;
+      err_exit:
+	hostlist_destroy(hl);
+	return SLURM_ERROR;
+}
+
+static int _pack_ranges(pmixp_coll_t *coll)
+{
+	pmix_proc_t *procs = coll->procs;
+	size_t nprocs = coll->nprocs;
+	uint32_t size;
+	int i;
+
+	/* 1. store the type of collective */
+	size = coll->type;
+	pack32(size, coll->buf);
+
+	/* 2. Put the number of ranges */
+	pack32(nprocs, coll->buf);
+	for (i = 0; i < (int)nprocs; i++) {
+		/* Pack namespace */
+		packmem(procs->nspace, strlen(procs->nspace) + 1, coll->buf);
+		pack32(procs->rank, coll->buf);
+	}
+
+	return SLURM_SUCCESS;
+}
+
+static void _reset_coll(pmixp_coll_t *coll)
+{
+	switch (coll->state) {
+	case PMIXP_COLL_SYNC:
+		/* already reset */
+		break;
+	case PMIXP_COLL_FAN_IN:
+	case PMIXP_COLL_FAN_OUT:
+		set_buf_offset(coll->buf, coll->serv_offs);
+		if (SLURM_SUCCESS != _pack_ranges(coll)) {
+			PMIXP_ERROR(
+					"Cannot pack ranges to coll message header!");
+		}
+		coll->state = PMIXP_COLL_SYNC;
+		memset(coll->ch_contribs, 0, sizeof(int) * coll->children_cnt);
+		coll->seq++; /* move to the next collective */
+		coll->contrib_cntr = 0;
+		coll->cbdata = NULL;
+		coll->cbfunc = NULL;
+		break;
+	default:
+		PMIXP_ERROR("Bad collective state = %d", coll->state);
+	}
+}
+
+int pmixp_coll_unpack_ranges(Buf buf, pmixp_coll_type_t *type,
+		pmix_proc_t **r, size_t *nr)
+{
+	pmix_proc_t *procs = NULL;
+	uint32_t nprocs = 0;
+	uint32_t tmp;
+	int i, rc;
+
+	/* 1. extract the type of collective */
+	if (SLURM_SUCCESS != (rc = unpack32(&tmp, buf))) {
+		PMIXP_ERROR("Cannot unpack collective type");
+		return rc;
+	}
+	*type = tmp;
+
+	/* 2. get the number of ranges */
+	if (SLURM_SUCCESS != (rc = unpack32(&nprocs, buf))) {
+		PMIXP_ERROR("Cannot unpack collective type");
+		return rc;
+	}
+	*nr = nprocs;
+
+	procs = xmalloc(sizeof(pmix_proc_t) * nprocs);
+	*r = procs;
+
+	for (i = 0; i < (int)nprocs; i++) {
+		/* 3. get namespace/rank of particular process */
+		rc = unpackmem(procs[i].nspace, &tmp, buf);
+		if (SLURM_SUCCESS != rc) {
+			PMIXP_ERROR("Cannot unpack namespace for process #%d",
+					i);
+			return rc;
+		}
+		procs[i].nspace[tmp] = '\0';
+
+		unsigned int tmp;
+		rc = unpack32(&tmp, buf);
+		procs[i].rank = tmp;
+		if (SLURM_SUCCESS != rc) {
+			PMIXP_ERROR(
+					"Cannot unpack ranks for process #%d, nsp=%s",
+					i, procs[i].nspace);
+			return rc;
+		}
+	}
+	return SLURM_SUCCESS;
+}
+
+int pmixp_coll_belong_chk(pmixp_coll_type_t type,
+			  const pmix_proc_t *procs, size_t nprocs)
+{
+	int i;
+	pmixp_namespace_t *nsptr = pmixp_nspaces_local();
+	/* Find my namespace in the range */
+	for (i = 0; i < nprocs; i++) {
+		if (0 != strcmp(procs[i].nspace, nsptr->name)) {
+			continue;
+		}
+		if ((procs[i].rank == PMIX_RANK_WILDCARD))
+			return 0;
+		if (0 <= pmixp_info_taskid2localid(procs[i].rank)) {
+			return 0;
+		}
+	}
+	/* we don't participate in this collective! */
+	PMIXP_ERROR("Have collective that doesn't include this job's namespace");
+	return -1;
+}
+
+/*
+ * Based on ideas provided by Hongjia Cao <hjcao@nudt.edu.cn> in PMI2 plugin
+ */
+int pmixp_coll_init(pmixp_coll_t *coll, const pmix_proc_t *procs,
+		size_t nprocs, pmixp_coll_type_t type)
+{
+	hostlist_t hl;
+	uint32_t nodeid = 0, nodes = 0;
+	int parent_id, depth, max_depth, tmp;
+	int width, my_nspace = -1;
+	char *p;
+	int i, *ch_nodeids = NULL;
+
+#ifndef NDEBUG
+	coll->magic = PMIXP_COLL_STATE_MAGIC;
+#endif
+	coll->type = type;
+	coll->state = PMIXP_COLL_SYNC;
+	coll->procs = xmalloc(sizeof(*procs) * nprocs);
+	memcpy(coll->procs, procs, sizeof(*procs) * nprocs);
+	coll->nprocs = nprocs;
+	coll->my_nspace = my_nspace;
+
+	if (SLURM_SUCCESS != _hostset_from_ranges(procs, nprocs, &hl)) {
+		/* TODO: provide ranges output routine */
+		PMIXP_ERROR("Bad ranges information");
+		goto err_exit;
+	}
+
+	width = slurm_get_tree_width();
+	nodes = hostlist_count(hl);
+	nodeid = hostlist_find(hl, pmixp_info_hostname());
+	reverse_tree_info(nodeid, nodes, width, &parent_id, &tmp, &depth,
+			&max_depth);
+	coll->children_cnt = tmp;
+	coll->nodeid = nodeid;
+
+	/* We interested in amount of direct childs */
+	coll->seq = 0;
+	coll->contrib_cntr = 0;
+	coll->contrib_local = false;
+	ch_nodeids = xmalloc(sizeof(int) * width);
+	coll->ch_contribs = xmalloc(sizeof(int) * width);
+	coll->children_cnt = reverse_tree_direct_children(nodeid, nodes, width,
+			depth, ch_nodeids);
+
+	/* create the hostlist with extract direct children's hostnames */
+	coll->ch_hosts = hostlist_create("");
+	for (i = 0; i < coll->children_cnt; i++) {
+		char *hname = hostlist_nth(hl, ch_nodeids[i]);
+		hostlist_push(coll->ch_hosts, hname);
+	}
+	/* just in case, shouldn't be needed */
+	hostlist_uniq(coll->ch_hosts);
+	xfree(ch_nodeids[i]);
+
+	if (parent_id == -1) {
+		/* if we are the root of the tree:
+		 * - we don't have a parent;
+		 * - we have large list of all_childrens (we don't want ourselfs there)
+		 */
+		coll->parent_host = NULL;
+		hostlist_delete_host(hl, pmixp_info_hostname());
+		coll->all_children = hl;
+	} else if (parent_id >= 0) {
+		/* for all other nodes in the tree we need to know:
+		 * - nodename of our parent;
+		 * - we don't need a list of all_childrens and hl anymore
+		 */
+		p = hostlist_nth(hl, parent_id);
+		coll->parent_host = xstrdup(p);
+		/* use empty hostlist here */
+		coll->all_children = hostlist_create("");
+		free(p);
+		hostlist_destroy(hl);
+	}
+
+	/* Collective data */
+	coll->buf = pmixp_server_new_buf();
+	coll->serv_offs = get_buf_offset(coll->buf);
+
+	if (SLURM_SUCCESS != _pack_ranges(coll)) {
+		PMIXP_ERROR("Cannot pack ranges to coll message header!");
+		goto err_exit;
+	}
+
+	/* Callback information */
+	coll->cbdata = NULL;
+	coll->cbfunc = NULL;
+
+	/* init fine grained lock */
+	pthread_mutexattr_t attr;
+	pthread_mutexattr_init(&attr);
+	pthread_mutex_init(&coll->lock, &attr);
+	pthread_mutexattr_destroy(&attr);
+
+	return SLURM_SUCCESS;
+      err_exit:
+	return SLURM_ERROR;
+}
+
+void pmixp_coll_free(pmixp_coll_t *coll)
+{
+	if (NULL != coll->procs) {
+		xfree(coll->procs);
+	}
+	if (NULL != coll->parent_host) {
+		xfree(coll->parent_host);
+	}
+	hostlist_destroy(coll->all_children);
+	hostlist_destroy(coll->ch_hosts);
+
+	if (NULL != coll->ch_contribs) {
+		xfree(coll->ch_contribs);
+	}
+	free_buf(coll->buf);
+}
+
+int pmixp_coll_contrib_local(pmixp_coll_t *coll, char *data, size_t size)
+{
+	PMIXP_DEBUG("%s:%d: get local contribution", pmixp_info_namespace(),
+			pmixp_info_nodeid());
+
+	/* sanity check */
+	pmixp_coll_sanity_check(coll);
+
+	/* lock the structure */
+	pthread_mutex_lock(&coll->lock);
+
+	/* change the collective state if need */
+	if (PMIXP_COLL_SYNC == coll->state) {
+		PMIXP_DEBUG(
+				"%s:%d: get local contribution: switch to PMIXP_COLL_FAN_IN",
+				pmixp_info_namespace(), pmixp_info_nodeid());
+		coll->state = PMIXP_COLL_FAN_IN;
+		coll->ts = time(NULL);
+	}
+	xassert(PMIXP_COLL_FAN_IN == coll->state);
+
+	/* save & mark local contribution */
+	coll->contrib_local = true;
+	grow_buf(coll->buf, size);
+	memcpy(get_buf_data(coll->buf) + get_buf_offset(coll->buf), data, size);
+	set_buf_offset(coll->buf, get_buf_offset(coll->buf) + size);
+
+	/* unlock the structure */
+	pthread_mutex_unlock(&coll->lock);
+
+	/* check if the collective is ready to progress */
+	_progress_fan_in(coll);
+
+	PMIXP_DEBUG("%s:%d: get local contribution: finish",
+			pmixp_info_namespace(), pmixp_info_nodeid());
+
+	return SLURM_SUCCESS;
+}
+
+int pmixp_coll_contrib_node(pmixp_coll_t *coll, char *nodename, Buf buf)
+{
+	int nodeid;
+	char *data = NULL;
+	uint32_t size;
+
+	PMIXP_DEBUG("%s:%d: get contribution from node %s",
+			pmixp_info_namespace(), pmixp_info_nodeid(), nodename);
+
+	/* lock the structure */
+	pthread_mutex_lock(&coll->lock);
+
+	pmixp_coll_sanity_check(coll);
+
+	/* fix the collective status if need */
+	if (PMIXP_COLL_SYNC == coll->state) {
+		PMIXP_DEBUG(
+				"%s:%d: get contribution from node %s: switch to PMIXP_COLL_FAN_IN",
+				pmixp_info_namespace(), pmixp_info_nodeid(),
+				nodename);
+		coll->state = PMIXP_COLL_FAN_IN;
+		coll->ts = time(NULL);
+	}
+	xassert(PMIXP_COLL_FAN_IN == coll->state);
+
+	/* Because of possible timeouts/delays in transmission we
+	 * can receive a contribution second time. Avoid duplications
+	 * by checking our records. */
+	nodeid = hostlist_find(coll->ch_hosts, nodename);
+	xassert(0 <= nodeid);
+	if (0 > nodeid) {
+		/* protect ourselfs if we are running with no asserts */
+		goto proceed;
+	}
+
+	if (0 < coll->ch_contribs[nodeid]) {
+		/* May be 0 or 1. If grater - transmission skew, ignore. */
+		PMIXP_DEBUG(
+				"Multiple contributions from child_id=%d, hostname=%s",
+				nodeid, nodename);
+		/* this is duplication, skip. */
+		goto proceed;
+	}
+
+	data = get_buf_data(buf) + get_buf_offset(buf);
+	size = remaining_buf(buf);
+	grow_buf(coll->buf, size);
+	memcpy(get_buf_data(coll->buf) + get_buf_offset(coll->buf), data, size);
+	set_buf_offset(coll->buf, get_buf_offset(coll->buf) + size);
+
+	/* increase number of individual contributions */
+	coll->ch_contribs[nodeid]++;
+
+	/* increase number of total contributions */
+	coll->contrib_cntr++;
+
+	proceed:
+	/* unlock the structure */
+	pthread_mutex_unlock(&coll->lock);
+
+	/* make a progress */
+	_progress_fan_in(coll);
+
+	PMIXP_DEBUG("%s:%d: get contribution from node %s: finish",
+			pmixp_info_namespace(), pmixp_info_nodeid(), nodename);
+
+	return SLURM_SUCCESS;
+}
+
+void pmixp_coll_bcast(pmixp_coll_t *coll, Buf buf)
+{
+	PMIXP_DEBUG("%s:%d: start", pmixp_info_namespace(), pmixp_info_nodeid());
+
+	/* lock the structure */
+	pthread_mutex_lock(&coll->lock);
+
+	_progres_fan_out(coll, buf);
+
+	/* unlock the structure */
+	pthread_mutex_unlock(&coll->lock);
+}
+
+static int _copy_payload(Buf inbuf, size_t offs, Buf *outbuf)
+{
+	size_t total_size, copy_size;
+	char *ptr;
+	pmix_proc_t *procs = NULL;
+	size_t nprocs = 0;
+	pmixp_coll_type_t type = 0;
+	Buf buf;
+
+	total_size = get_buf_offset(inbuf);
+	set_buf_offset(inbuf, offs);
+	int rc = pmixp_coll_unpack_ranges(inbuf, &type, &procs, &nprocs);
+	xfree(procs);
+	ptr = get_buf_data(inbuf) + get_buf_offset(inbuf);
+	copy_size = total_size - get_buf_offset(inbuf);
+	buf = init_buf(copy_size);
+	memcpy(get_buf_data(buf), ptr, copy_size);
+	*outbuf = buf;
+	return rc;
+}
+
+static void _progress_fan_in(pmixp_coll_t *coll)
+{
+	pmixp_srv_cmd_t type;
+	const char *addr = pmixp_info_srv_addr();
+	char *hostlist = NULL;
+	int rc;
+
+	PMIXP_DEBUG("%s:%d: start, local=%d, child_cntr=%d",
+			pmixp_info_namespace(), pmixp_info_nodeid(),
+			coll->contrib_local, coll->contrib_cntr);
+
+	/* lock the collective */
+	pthread_mutex_lock(&coll->lock);
+
+	pmixp_coll_sanity_check(coll);
+
+	if (PMIXP_COLL_FAN_IN != coll->state) {
+		/* In case of race condition between libpmix and
+		 * slurm threads progress_fan_in can be called
+		 * after we moved to the next step. */
+		goto unlock;
+	}
+
+	if (!coll->contrib_local || coll->contrib_cntr != coll->children_cnt) {
+		/* Not yet ready to go to the next step */
+		goto unlock;
+	}
+
+	/* The root of the collective will have parent_host == NULL */
+	if (NULL != coll->parent_host) {
+		hostlist = xstrdup(coll->parent_host);
+		type = PMIXP_MSG_FAN_IN;
+	} else {
+		if (0 < hostlist_count(coll->all_children)) {
+			hostlist = hostlist_ranged_string_xmalloc(
+					coll->all_children);
+			type = PMIXP_MSG_FAN_OUT;
+			pmixp_debug_hang(0);
+		}
+	}
+
+	PMIXP_DEBUG("%s:%d: send data to %s", pmixp_info_namespace(),
+			pmixp_info_nodeid(), hostlist);
+
+	/* Check for the singletone case */
+	if (NULL != hostlist) {
+		rc = pmixp_server_send(hostlist, type, coll->seq, addr,
+				get_buf_data(coll->buf),
+				get_buf_offset(coll->buf));
+
+		if (SLURM_SUCCESS != rc) {
+			PMIXP_ERROR(
+					"Cannot send data (size = %lu), to hostlist:\n%s",
+					(uint64_t) get_buf_offset(coll->buf),
+					hostlist);
+			/* return error indication to PMIx. Nodes that haven't received data
+			 * will exit by a timeout.
+			 * FIXME: do we need to do something with successfuly finished nodes?
+			 */
+			goto unlock;
+		}
+	}
+
+	/* transit to the next state */
+	coll->state = PMIXP_COLL_FAN_OUT;
+
+	/* if we are root - push data to PMIx here.
+	 * Originally there was a homogenuous solution: root nodename was in the hostlist.
+	 * However this may lead to the undesired side effects: we are blocked here sending
+	 * data and cannot receive (it will be triggered in this thread after we will leave
+	 * this callback), so we have to rely on buffering on the SLURM side.
+	 * Better not to do so. */
+	if (NULL == coll->parent_host) {
+		/* if I am the root - pass the data to PMIx and reset collective here */
+		PMIXP_DEBUG(
+				"%s:%d: finish with this collective (I am the root)",
+				pmixp_info_namespace(), pmixp_info_nodeid());
+		/* copy payload excluding reserved server header */
+		Buf buf;
+		int rc;
+		rc = _copy_payload(coll->buf, coll->serv_offs, &buf);
+		xassert(0 == rc);
+		_progres_fan_out(coll, buf);
+	} else {
+		/* if root is not me - wait for the data */
+		PMIXP_DEBUG("%s:%d: switch to PMIXP_COLL_FAN_OUT state",
+				pmixp_info_namespace(), pmixp_info_nodeid());
+		/* reset the old buffer */
+		set_buf_offset(coll->buf, 0);
+	}
+
+      unlock:
+	if (NULL != hostlist) {
+		xfree(hostlist);
+	}
+
+	/* lock the */
+	pthread_mutex_unlock(&coll->lock);
+}
+
+void _progres_fan_out(pmixp_coll_t *coll, Buf buf)
+{
+	PMIXP_DEBUG("%s:%d: start", pmixp_info_namespace(), pmixp_info_nodeid());
+
+	pmixp_coll_sanity_check(coll);
+
+	xassert(PMIXP_COLL_FAN_OUT == coll->state);
+
+	/* update the database */
+	if (NULL != coll->cbfunc) {
+		void *data = get_buf_data(buf) + get_buf_offset(buf);
+		size_t size = remaining_buf(buf);
+		PMIXP_DEBUG("%s:%d: use the callback", pmixp_info_namespace(),
+				pmixp_info_nodeid());
+		coll->cbfunc(PMIX_SUCCESS, data, size, coll->cbdata,
+				pmixp_free_Buf, (void *)buf);
+	}
+	/* Prepare for the next collective operation */
+	_reset_coll(coll);
+
+	PMIXP_DEBUG("%s:%d: collective is prepared for the next use",
+			pmixp_info_namespace(), pmixp_info_nodeid());
+}
+
+void pmixp_coll_reset_if_to(pmixp_coll_t *coll, time_t ts)
+{
+	/* lock the */
+	pthread_mutex_lock(&coll->lock);
+
+	if (PMIXP_COLL_SYNC == coll->state) {
+		goto unlock;
+	}
+
+	if (ts - coll->ts > pmixp_info_timeout()) {
+		/* respond to the libpmix */
+		coll->cbfunc(PMIX_ERR_TIMEOUT, NULL, 0, coll->cbdata, NULL,
+				NULL);
+		/* drop the collective */
+		_reset_coll(coll);
+		/* report the timeout event */
+		PMIXP_ERROR("Collective timeout!");
+	}
+	unlock:
+	/* unlock the structure */
+	pthread_mutex_unlock(&coll->lock);
+}
diff --git a/src/plugins/mpi/pmix/pmixp_coll.h b/src/plugins/mpi/pmix/pmixp_coll.h
new file mode 100644
index 0000000..2c05834
--- /dev/null
+++ b/src/plugins/mpi/pmix/pmixp_coll.h
@@ -0,0 +1,193 @@
+/*****************************************************************************\
+ **  pmix_coll.h - PMIx collective primitives
+ *****************************************************************************
+ *  Copyright (C) 2014-2015 Artem Polyakov. All rights reserved.
+ *  Copyright (C) 2015      Mellanox Technologies. All rights reserved.
+ *  Written by Artem Polyakov <artpol84@gmail.com, artemp@mellanox.com>.
+ *
+ *  This file is part of SLURM, a resource management program.
+ *  For details, see <http://slurm.schedmd.com/>.
+ *  Please also read the included file: DISCLAIMER.
+ *
+ *  SLURM is free software; you can redistribute it and/or modify it under
+ *  the terms of the GNU General Public License as published by the Free
+ *  Software Foundation; either version 2 of the License, or (at your option)
+ *  any later version.
+ *
+ *  In addition, as a special exception, the copyright holders give permission
+ *  to link the code of portions of this program with the OpenSSL library under
+ *  certain conditions as described in each individual source file, and
+ *  distribute linked combinations including the two. You must obey the GNU
+ *  General Public License in all respects for all of the code used other than
+ *  OpenSSL. If you modify file(s) with this exception, you may extend this
+ *  exception to your version of the file(s), but you are not obligated to do
+ *  so. If you do not wish to do so, delete this exception statement from your
+ *  version.  If you delete this exception statement from all source files in
+ *  the program, then also delete it here.
+ *
+ *  SLURM is distributed in the hope that it will be useful, but WITHOUT ANY
+ *  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+ *  FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
+ *  details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with SLURM; if not, write to the Free Software Foundation, Inc.,
+ *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA.
+ \*****************************************************************************/
+
+#ifndef PMIXP_COLL_H
+#define PMIXP_COLL_H
+#include "pmixp_common.h"
+#include "pmixp_debug.h"
+
+typedef enum {
+	PMIXP_COLL_SYNC,
+	PMIXP_COLL_FAN_IN,
+	PMIXP_COLL_FAN_OUT
+} pmixp_coll_state_t;
+
+typedef enum {
+	PMIXP_COLL_TYPE_FENCE,
+	PMIXP_COLL_TYPE_CONNECT,
+	PMIXP_COLL_TYPE_DISCONNECT
+} pmixp_coll_type_t;
+
+typedef struct {
+#ifndef NDEBUG
+#define PMIXP_COLL_STATE_MAGIC 0xCA11CAFE
+	int magic;
+#endif
+	/* element-wise lock */
+	pthread_mutex_t lock;
+
+	/* general information */
+	pmixp_coll_state_t state;
+	pmixp_coll_type_t type;
+	/* PMIx collective id */
+	pmix_proc_t *procs;
+	size_t nprocs;
+	int my_nspace;
+	uint32_t nodeid;
+	/* tree structure */
+	char *parent_host;
+	hostlist_t all_children;
+	uint32_t children_cnt;
+
+	/* */
+	uint32_t seq;
+	uint32_t contrib_cntr;
+	bool contrib_local;
+
+	/* Check who contributes */
+	hostlist_t ch_hosts;
+	bool *ch_contribs;
+
+	/* collective data */
+	Buf buf;
+	size_t serv_offs;
+
+	/* libpmix callback data */
+	pmix_modex_cbfunc_t cbfunc;
+	void *cbdata;
+
+	/* timestamp for stale collectives detection */
+	time_t ts;
+} pmixp_coll_t;
+
+static inline void pmixp_coll_sanity_check(pmixp_coll_t *coll)
+{
+	xassert(coll->magic == PMIXP_COLL_STATE_MAGIC);
+}
+
+int pmixp_coll_init(pmixp_coll_t *coll, const pmix_proc_t *procs,
+		size_t nprocs, pmixp_coll_type_t type);
+void pmixp_coll_free(pmixp_coll_t *coll);
+
+static inline void pmixp_coll_set_callback(pmixp_coll_t *coll,
+					   pmix_modex_cbfunc_t cbfunc,
+					   void *cbdata)
+{
+	/* no need to protect coll since:
+	 * - only libpmix thread may touch this data during fan-in stage
+	 * - only slurm thread may touch this data during fan-out stage
+	 */
+	pmixp_coll_sanity_check(coll);
+	coll->cbfunc = cbfunc;
+	coll->cbdata = cbdata;
+}
+
+/*
+ * This is important routine that takes responsibility to decide
+ * what messages may appear and what may not. In absence of errors
+ * we won't need this routine. Unfortunately they are exist.
+ * There can be 3 general types of communication errors:
+ * 1. We are trying to send our contribution to a parent and it fails.
+ *    In this case we will be blocked in send function. At some point
+ *    we either succeed or fail after predefined number of trials.
+ *
+ *    If we succeed - we are OK. Otherwise we will abort the whole job step.
+ *
+ * 2. A child of us sends us the message and gets the error, however we
+ *    receive this message (false negative). Child will try again while we might be:
+ *    (a) at FAN-IN step waiting for other contributions.
+ *    (b) at FAN-OUT since we get all we need.
+ *    (c) 2 step forward (SYNC) with coll->seq = (child_seq+1) if root of the tree
+ *        successfuly broadcasted the whole database to us.
+ *    (d) 3 step forward (next FAN-IN) with coll->seq = (child_seq+1)
+ *        if somebody initiated next collective.
+ *    (e) we won't move further because the child with problem won't send us
+ *        next contribution.
+ *
+ *    Cases (a) and (b) can't be noticed here since child and we have the
+ *    same seq number. They will later be detected  in pmixp_coll_contrib_node()
+ *    based on collective contribution accounting vector.
+ *
+ *    Cases (c) and (d) would be visible here and should be treated as possible
+ *    errors that should be ignored discarding the contribution.
+ *
+ *    Other cases are obvious error, we can abort in this case or ignore with
+ *    error.
+ *
+ * 3. Root of the tree broadcasts the data and we get it, however root gets
+ *    false negative. In this case root will try again. We might be:
+ *    (a) at SYNC since we just got the DB and we are fine (coll->seq == root_seq+1)
+ *    (b) at FAN-IN if somebody initiated next collective  (coll->seq == root_seq+1)
+ *    (c) at FAN-OUT if we will collect all necessary contributions and send it to
+ *        our parent.
+ *    (d) we won't be able to switch to SYNC since root will be busy dealing with
+ *        previous DB broadcast.
+ */
+static inline int pmixp_coll_check_seq(pmixp_coll_t *coll, uint32_t seq,
+		char *nodename)
+{
+	if (coll->seq == seq) {
+		/* accept this message */
+		return SLURM_SUCCESS;
+	} else if ((coll->seq - 1) == seq) {
+		/* his may be our child OR root of the tree that
+		 * had false negatives from SLURM protocol.
+		 * It's normal situation, return error because we
+		 * want to discard this message */
+		return SLURM_ERROR;
+	}
+	PMIXP_ERROR("Bad collective seq. #%d from %s, current is %d", seq,
+			nodename, coll->seq);
+	/* maybe need more sophisticated handling in presence of
+	 * several steps. However maybe it's enough to just ignore */
+	/* slurm_kill_job_step(pmixp_info_jobid(), pmixp_info_stepid(), SIGKILL); */
+	return SLURM_ERROR;
+}
+
+int pmixp_coll_contrib_local(pmixp_coll_t *coll, char *data,
+			     size_t ndata);
+int pmixp_coll_contrib_node(pmixp_coll_t *coll, char *nodename, Buf buf);
+void pmixp_coll_bcast(pmixp_coll_t *coll, Buf buf);
+bool pmixp_coll_progress(pmixp_coll_t *coll, char *fwd_node,
+			 void **data, uint64_t size);
+int pmixp_coll_unpack_ranges(Buf buf, pmixp_coll_type_t *type,
+		pmix_proc_t **ranges, size_t *nranges);
+int pmixp_coll_belong_chk(pmixp_coll_type_t type,
+			  const pmix_proc_t *procs, size_t nprocs);
+void pmixp_coll_reset_if_to(pmixp_coll_t *coll, time_t ts);
+
+#endif /* PMIXP_COLL_H */
diff --git a/src/plugins/mpi/pmix/pmixp_common.h b/src/plugins/mpi/pmix/pmixp_common.h
new file mode 100644
index 0000000..b217662
--- /dev/null
+++ b/src/plugins/mpi/pmix/pmixp_common.h
@@ -0,0 +1,88 @@
+/*****************************************************************************\
+ **  pmix_common.h - PMIx common declarations and includes
+ *****************************************************************************
+ *  Copyright (C) 2014-2015 Artem Polyakov. All rights reserved.
+ *  Copyright (C) 2015      Mellanox Technologies. All rights reserved.
+ *  Written by Artem Polyakov <artpol84@gmail.com, artemp@mellanox.com>.
+ *
+ *  This file is part of SLURM, a resource management program.
+ *  For details, see <http://slurm.schedmd.com/>.
+ *  Please also read the included file: DISCLAIMER.
+ *
+ *  SLURM is free software; you can redistribute it and/or modify it under
+ *  the terms of the GNU General Public License as published by the Free
+ *  Software Foundation; either version 2 of the License, or (at your option)
+ *  any later version.
+ *
+ *  In addition, as a special exception, the copyright holders give permission
+ *  to link the code of portions of this program with the OpenSSL library under
+ *  certain conditions as described in each individual source file, and
+ *  distribute linked combinations including the two. You must obey the GNU
+ *  General Public License in all respects for all of the code used other than
+ *  OpenSSL. If you modify file(s) with this exception, you may extend this
+ *  exception to your version of the file(s), but you are not obligated to do
+ *  so. If you do not wish to do so, delete this exception statement from your
+ *  version.  If you delete this exception statement from all source files in
+ *  the program, then also delete it here.
+ *
+ *  SLURM is distributed in the hope that it will be useful, but WITHOUT ANY
+ *  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+ *  FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
+ *  details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with SLURM; if not, write to the Free Software Foundation, Inc.,
+ *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA.
+ \*****************************************************************************/
+
+#ifndef PMIXP_COMMON_H
+#define PMIXP_COMMON_H
+
+#include <unistd.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <sys/un.h>
+#include <stdlib.h>
+#include <unistd.h>
+
+/* Common includes for all source files
+ * Define SLURM translator header first to override
+ * all translated functions
+ */
+#include "src/common/slurm_xlator.h"
+
+/* Other useful includes */
+#include "slurm/slurm_errno.h"
+#include "src/common/slurm_mpi.h"
+#include "src/slurmd/slurmstepd/slurmstepd_job.h"
+#include "src/common/xmalloc.h"
+#include "src/common/xassert.h"
+#include "src/common/eio.h"
+#include "src/common/mapping.h"
+#include "src/common/fd.h"
+#include "src/common/net.h"
+
+/* PMIx library header */
+#include <pmix_server.h>
+
+/* TODO: use /tmp directory instead */
+#define MAX_USOCK_PATH							\
+	((size_t) &(((struct sockaddr_un *)0 + 1)->sun_family) -	\
+	(size_t)&(((struct sockaddr_un *)0)->sun_path))
+
+/* Job/step resource description */
+#define PMIXP_STEP_NODES_ENV "SLURM_STEP_NODELIST"
+#define PMIXP_JOB_NODES_ENV "SLURM_JOB_NODELIST"
+#define PMIXP_CPUS_PER_NODE_ENV "SLURM_JOB_CPUS_PER_NODE"
+#define PMIXP_CPUS_PER_TASK "SLURM_CPUS_PER_TASK"
+#define PMIXP_SLURM_MAPPING_ENV "SLURM_PMIX_MAPPING_SERV"
+/* Mode */
+#define PMIXP_TIMEOUT "SLURM_PMIX_TIMEOUT"
+#define PMIXP_TIMEOUT_DEFAULT 10
+#define PMIXP_TMPDIR_SRV "SLURM_PMIX_SRV_TMPDIR"
+#define PMIXP_TMPDIR_CLI "SLURM_PMIX_TMPDIR"
+#define PMIXP_TMPDIR_DEFAULT "/tmp/"
+#define PMIXP_OS_TMPDIR_ENV "TMPDIR"
+#define PMIXP_PMIXLIB_TMPDIR "PMIX_SERVER_TMPDIR"
+
+#endif /* PMIXP_COMMON_H */
diff --git a/src/plugins/mpi/pmix/pmixp_debug.h b/src/plugins/mpi/pmix/pmixp_debug.h
new file mode 100644
index 0000000..8a37fc9
--- /dev/null
+++ b/src/plugins/mpi/pmix/pmixp_debug.h
@@ -0,0 +1,114 @@
+/*****************************************************************************\
+ **  pmix_debug.h - PMIx debug primitives
+ *****************************************************************************
+ *  Copyright (C) 2014-2015 Artem Polyakov. All rights reserved.
+ *  Copyright (C) 2015      Mellanox Technologies. All rights reserved.
+ *  Written by Artem Polyakov <artpol84@gmail.com, artemp@mellanox.com>.
+ *
+ *  This file is part of SLURM, a resource management program.
+ *  For details, see <http://slurm.schedmd.com/>.
+ *  Please also read the included file: DISCLAIMER.
+ *
+ *  SLURM is free software; you can redistribute it and/or modify it under
+ *  the terms of the GNU General Public License as published by the Free
+ *  Software Foundation; either version 2 of the License, or (at your option)
+ *  any later version.
+ *
+ *  In addition, as a special exception, the copyright holders give permission
+ *  to link the code of portions of this program with the OpenSSL library under
+ *  certain conditions as described in each individual source file, and
+ *  distribute linked combinations including the two. You must obey the GNU
+ *  General Public License in all respects for all of the code used other than
+ *  OpenSSL. If you modify file(s) with this exception, you may extend this
+ *  exception to your version of the file(s), but you are not obligated to do
+ *  so. If you do not wish to do so, delete this exception statement from your
+ *  version.  If you delete this exception statement from all source files in
+ *  the program, then also delete it here.
+ *
+ *  SLURM is distributed in the hope that it will be useful, but WITHOUT ANY
+ *  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+ *  FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
+ *  details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with SLURM; if not, write to the Free Software Foundation, Inc.,
+ *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA.
+ \*****************************************************************************/
+#ifndef PMIXP_DEBUG_H
+#define PMIXP_DEBUG_H
+
+#include "pmixp_common.h"
+#include "pmixp_info.h"
+
+#define MAX_MSG_SIZE 1024
+
+#define PMIXP_DEBUG(format, args...) {				\
+	char file[] = __FILE__;					\
+	char *file_base = strrchr(file, '/');			\
+	if (file_base == NULL) {				\
+		file_base = file;				\
+	}							\
+	debug("%s [%d] %s:%d [%s] mpi/pmix: " format "",	\
+		pmixp_info_hostname(), pmixp_info_nodeid(),	\
+		file_base, __LINE__, __FUNCTION__,		\
+		## args);					\
+}
+
+#define PMIXP_ERROR_STD(format, args...) {			\
+	char file[] = __FILE__;					\
+	char *file_base = strrchr(file, '/');			\
+	if (file_base == NULL) {				\
+	file_base = file;					\
+	}							\
+	error("%s [%d] %s:%d [%s] mpi/pmix: ERROR: " format ": %s (%d)",	\
+		pmixp_info_hostname(), pmixp_info_nodeid(),	\
+		file_base, __LINE__, __FUNCTION__,		\
+		## args, strerror(errno), errno);		\
+}
+
+#define PMIXP_ERROR(format, args...) {				\
+	char file[] = __FILE__;					\
+	char *file_base = strrchr(file, '/');			\
+	if (file_base == NULL) {				\
+		file_base = file;				\
+	}							\
+	error("%s [%d] %s:%d [%s] mpi/pmix: ERROR: " format,	\
+		pmixp_info_hostname(), pmixp_info_nodeid(),	\
+		file_base, __LINE__, __FUNCTION__, ## args);	\
+}
+
+#define PMIXP_ABORT(format, args...) {				\
+	PMIXP_ERROR(format, ##args);                            \
+	error("%s [%d] %s:%d [%s] mpi/pmix: ERROR: " format,	\
+		pmixp_info_hostname(), pmixp_info_nodeid(),	\
+		file_base, __LINE__, __FUNCTION__, ## args);	\
+		slurm_kill_job_step(pmixp_info_jobid(),         \
+		pmixp_info_stepid(), SIGKILL);			\
+}
+
+#define PMIXP_ERROR_NO(err, format, args...) {			\
+	char file[] = __FILE__;					\
+	char *file_base = strrchr(file, '/');			\
+	if (file_base == NULL) {				\
+		file_base = file;				\
+	}							\
+	error("%s [%d] %s:%d [%s] mpi/pmix: ERROR: " format ": %s (%d)", \
+		pmixp_info_hostname(), pmixp_info_nodeid(),	\
+		file_base, __LINE__, __FUNCTION__,		\
+		## args, strerror(err), err);			\
+}
+
+#ifdef NDEBUG
+#define pmixp_debug_hang(x)
+#else
+static inline void _pmixp_debug_hang(int delay)
+{
+	while (delay) {
+		sleep(1);
+	}
+}
+
+#define pmixp_debug_hang(x) _pmixp_debug_hang(x)
+
+#endif
+#endif /* PMIXP_DEBUG_H */
diff --git a/src/plugins/mpi/pmix/pmixp_dmdx.c b/src/plugins/mpi/pmix/pmixp_dmdx.c
new file mode 100644
index 0000000..21845cf
--- /dev/null
+++ b/src/plugins/mpi/pmix/pmixp_dmdx.c
@@ -0,0 +1,478 @@
+/*****************************************************************************\
+ **  pmix_debug.h - PMIx debug primitives
+ *****************************************************************************
+ *  Copyright (C) 2014-2015 Artem Polyakov. All rights reserved.
+ *  Copyright (C) 2015      Mellanox Technologies. All rights reserved.
+ *  Written by Artem Polyakov <artpol84@gmail.com, artemp@mellanox.com>.
+ *
+ *  This file is part of SLURM, a resource management program.
+ *  For details, see <http://slurm.schedmd.com/>.
+ *  Please also read the included file: DISCLAIMER.
+ *
+ *  SLURM is free software; you can redistribute it and/or modify it under
+ *  the terms of the GNU General Public License as published by the Free
+ *  Software Foundation; either version 2 of the License, or (at your option)
+ *  any later version.
+ *
+ *  In addition, as a special exception, the copyright holders give permission
+ *  to link the code of portions of this program with the OpenSSL library under
+ *  certain conditions as described in each individual source file, and
+ *  distribute linked combinations including the two. You must obey the GNU
+ *  General Public License in all respects for all of the code used other than
+ *  OpenSSL. If you modify file(s) with this exception, you may extend this
+ *  exception to your version of the file(s), but you are not obligated to do
+ *  so. If you do not wish to do so, delete this exception statement from your
+ *  version.  If you delete this exception statement from all source files in
+ *  the program, then also delete it here.
+ *
+ *  SLURM is distributed in the hope that it will be useful, but WITHOUT ANY
+ *  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+ *  FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
+ *  details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with SLURM; if not, write to the Free Software Foundation, Inc.,
+ *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA.
+ \*****************************************************************************/
+
+#include "pmixp_common.h"
+#include "pmixp_dmdx.h"
+#include "pmixp_server.h"
+
+/* set default direct modex timeout to 10 sec */
+#define DMDX_DEFAULT_TIMEOUT 10
+
+typedef enum {
+	DMDX_REQUEST = 1,
+	DMDX_RESPONSE
+} dmdx_type_t;
+
+typedef struct {
+	uint32_t seq_num;
+	time_t ts;
+#ifndef NDEBUG
+	/* we need this only for verification */
+	char nspace[PMIX_MAX_NSLEN];
+	int rank;
+#endif
+	pmix_modex_cbfunc_t cbfunc;
+	void *cbdata;
+} dmdx_req_info_t;
+
+typedef struct {
+	uint32_t seq_num;
+	pmix_proc_t proc;
+	char *sender_host, *sender_ns;
+	int rank;
+} dmdx_caddy_t;
+
+void _dmdx_free_caddy(dmdx_caddy_t *caddy)
+{
+	if (NULL == caddy) {
+		/* nothing to do */
+		return;
+	}
+	if (NULL != caddy->sender_host) {
+		xfree(caddy->sender_host);
+	}
+	if (NULL != caddy->sender_ns) {
+		xfree(caddy->sender_ns);
+	}
+	xfree(caddy);
+}
+
+static List _dmdx_requests;
+static uint32_t _dmdx_seq_num = 1;
+
+static void _respond_with_error(int seq_num, char *sender_host,
+				char *sender_ns, int status);
+
+int pmixp_dmdx_init(void)
+{
+	_dmdx_requests = list_create(pmixp_xfree_xmalloced);
+	_dmdx_seq_num = 1;
+	return SLURM_SUCCESS;
+}
+
+int pmixp_dmdx_finalize(void)
+{
+	list_destroy(_dmdx_requests);
+	return 0;
+}
+
+
+static void _setup_header(Buf buf, dmdx_type_t t,
+			  const char *nspace, int rank, int status)
+{
+	char *str;
+	/* 1. pack message type */
+	unsigned char type = (char)t;
+	grow_buf(buf, sizeof(char));
+	pack8(type, buf);
+
+	/* 2. pack namespace _with_ '\0' (strlen(nspace) + 1)! */
+	packmem((char *)nspace, strlen(nspace) + 1, buf);
+
+	/* 3. pack rank */
+	grow_buf(buf, sizeof(int));
+	pack32((uint32_t)rank, buf);
+
+	/* 4. pack my rendezvous point - local namespace
+	 * ! _with_ '\0' (strlen(nspace) + 1) ! */
+	str = pmixp_info_namespace();
+	packmem(str, strlen(str) + 1, buf);
+
+	/* 5. pack the status */
+	pack32((uint32_t)status, buf);
+}
+
+static int _read_type(Buf buf, dmdx_type_t *type)
+{
+	unsigned char t;
+	int rc;
+	/* 1. unpack message type */
+	if (SLURM_SUCCESS != (rc = unpack8(&t, buf))) {
+		PMIXP_ERROR("Cannot unpack message type!");
+		return SLURM_ERROR;
+	}
+	*type = (dmdx_type_t)t;
+	return SLURM_SUCCESS;
+}
+
+static int _read_info(Buf buf, char **ns, int *rank,
+		      char **sender_ns, int *status)
+{
+	uint32_t cnt, uint32_tmp;
+	int rc;
+	*ns = NULL;
+	*sender_ns = NULL;
+
+	/* 1. unpack namespace */
+	if (SLURM_SUCCESS != (rc = unpackmem_ptr(ns, &cnt, buf))) {
+		PMIXP_ERROR("Cannot unpack requested namespace!");
+		return rc;
+	}
+	/* We supposed to unpack a whole null-terminated string (with '\0')!
+	 * (*ns)[cnt] = '\0';
+	 */
+
+	/* 2. unpack rank */
+	if (SLURM_SUCCESS != (rc = unpack32(&uint32_tmp, buf))) {
+		PMIXP_ERROR("Cannot unpack requested rank!");
+		return rc;
+	}
+	*rank = uint32_tmp;
+
+	if (SLURM_SUCCESS != (rc = unpackmem_ptr(sender_ns, &cnt, buf))) {
+		PMIXP_ERROR("Cannot unpack sender namespace!");
+		return rc;
+	}
+	/* We supposed to unpack a whole null-terminated string (with '\0')!
+	 * (*sender_ns)[cnt] = '\0';
+	 */
+
+	/* 4. unpack status */
+	if (SLURM_SUCCESS != (rc = unpack32(&uint32_tmp, buf))) {
+		PMIXP_ERROR("Cannot unpack rank!");
+		return rc;
+	}
+	*status = uint32_tmp;
+	return SLURM_SUCCESS;
+}
+
+static void _respond_with_error(int seq_num, char *sender_host,
+				char *sender_ns, int status)
+{
+	Buf buf = create_buf(NULL, 0);
+	char *addr;
+	int rc;
+
+	/* rank doesn't matter here, don't send it */
+	_setup_header(buf, DMDX_RESPONSE, pmixp_info_namespace(), -1, status);
+	/* generate namespace usocket name */
+	addr = pmixp_info_nspace_usock(sender_ns);
+	/* send response */
+	rc = pmixp_server_send(sender_host, PMIXP_MSG_DMDX, seq_num, addr,
+			get_buf_data(buf), get_buf_offset(buf));
+	if (SLURM_SUCCESS != rc) {
+		PMIXP_ERROR("Cannot send direct modex error" " response to %s",
+				sender_host);
+	}
+	xfree(addr);
+	free_buf(buf);
+}
+
+static void _dmdx_pmix_cb(pmix_status_t status, char *data, size_t sz,
+		void *cbdata)
+{
+	dmdx_caddy_t *caddy = (dmdx_caddy_t *)cbdata;
+	Buf buf = pmixp_server_new_buf();
+	char *addr;
+	int rc;
+
+	/* setup response header */
+	_setup_header(buf, DMDX_RESPONSE, caddy->proc.nspace, caddy->proc.rank,
+			status);
+
+	/* pack the response */
+	packmem(data, sz, buf);
+
+	/* setup response address */
+	addr = pmixp_info_nspace_usock(caddy->sender_ns);
+
+	/* send the request */
+	rc = pmixp_server_send(caddy->sender_host, PMIXP_MSG_DMDX,
+			caddy->seq_num, addr, get_buf_data(buf),
+			get_buf_offset(buf));
+	if (SLURM_SUCCESS != rc) {
+		/* not much we can do here. Caller will react by timeout */
+		PMIXP_ERROR("Cannot send direct modex response to %s",
+				caddy->sender_host);
+	}
+	xfree(addr);
+	free_buf(buf);
+	_dmdx_free_caddy(caddy);
+}
+
+int pmixp_dmdx_get(const char *nspace, int rank,
+		   pmix_modex_cbfunc_t cbfunc, void *cbdata)
+{
+	dmdx_req_info_t *req;
+	char *addr, *host;
+	Buf buf;
+	int rc;
+	uint32_t seq;
+
+	/* need to send the request */
+	host = pmixp_nspace_resolve(nspace, rank);
+	xassert(NULL != host);
+	if (NULL == host) {
+		return SLURM_ERROR;
+	}
+
+	buf = pmixp_server_new_buf();
+
+	/* setup message header */
+	_setup_header(buf, DMDX_REQUEST, nspace, rank, SLURM_SUCCESS);
+	/* generate namespace usocket name */
+	addr = pmixp_info_nspace_usock(nspace);
+	/* store cur seq. num and move to the next request */
+	seq = _dmdx_seq_num++;
+
+	/* send the request */
+	rc = pmixp_server_send(host, PMIXP_MSG_DMDX, seq, addr,
+			get_buf_data(buf), get_buf_offset(buf));
+
+	/* cleanup the resources */
+	xfree(addr);
+	free_buf(buf);
+
+	/* check the return status */
+	if (SLURM_SUCCESS != rc) {
+		PMIXP_ERROR("Cannot send direct modex request to %s", host);
+		cbfunc(PMIX_ERR_COMM_FAILURE, NULL, 0, cbdata, NULL, NULL);
+		return SLURM_ERROR;
+	}
+
+	/* track this request */
+	req = xmalloc(sizeof(dmdx_req_info_t));
+	req->seq_num = seq;
+	req->cbfunc = cbfunc;
+	req->cbdata = cbdata;
+	req->ts = time(NULL);
+#ifndef NDEBUG
+	strncpy(req->nspace, nspace, PMIX_MAX_NSLEN);
+	req->rank = rank;
+#endif
+	list_append(_dmdx_requests, req);
+	return rc;
+}
+
+static void _dmdx_req(Buf buf, char *sender_host, uint32_t seq_num)
+{
+	int rank, rc;
+	int status;
+	char *ns = NULL, *sender_ns = NULL;
+	pmixp_namespace_t *nsptr;
+	dmdx_caddy_t *caddy = NULL;
+
+	if (SLURM_SUCCESS
+			!= (rc = _read_info(buf, &ns, &rank, &sender_ns,
+					&status))) {
+		/* there is not much we can do here, but data corruption shouldn't happen */
+		PMIXP_ERROR(
+				"Fail to unpack header data in" " request from %s, rc = %d",
+				sender_host, rc);
+		goto exit;
+	}
+
+	if (0 != strcmp(ns, pmixp_info_namespace())) {
+		/* request for namespase that is not controlled by this daemon
+		 * considered as error. This may change in future.  */
+		PMIXP_ERROR(
+				"Bad request from %s: asked for" " nspace = %s, mine is %s",
+				sender_host, ns, pmixp_info_namespace());
+		_respond_with_error(seq_num, sender_host, sender_ns,
+				PMIX_ERR_INVALID_NAMESPACE);
+		goto exit;
+	}
+
+	nsptr = pmixp_nspaces_local();
+	if (nsptr->ntasks <= rank) {
+		PMIXP_ERROR(
+				"Bad request from %s: nspace \"%s\"" " has only %d ranks, asked for %d",
+				sender_host, ns, nsptr->ntasks, rank);
+		_respond_with_error(seq_num, sender_host, sender_ns,
+				PMIX_ERR_BAD_PARAM);
+		goto exit;
+	}
+
+	/* setup temp structure to handle information fro _dmdx_pmix_cb */
+	caddy = xmalloc(sizeof(dmdx_caddy_t));
+	caddy->seq_num = seq_num;
+
+	/* ns is a pointer inside incoming buffer */
+	strncpy(caddy->proc.nspace, ns, PMIX_MAX_NSLEN);
+	ns = NULL; /* protect the data */
+	caddy->proc.rank = rank;
+
+	/* sender_host was passed from outside - copy it */
+	caddy->sender_host = xstrdup(sender_host);
+	sender_host = NULL; /* protect the data */
+
+	/* sender_ns is a pointer inside incoming buffer */
+	caddy->sender_ns = xstrdup(sender_ns);
+	sender_ns = NULL;
+
+	rc = PMIx_server_dmodex_request(&caddy->proc, _dmdx_pmix_cb,
+			(void *)caddy);
+	if (PMIX_SUCCESS != rc) {
+		PMIXP_ERROR(
+				"Can't request modex data from libpmix-server," "requesting host = %s, nspace = %s, rank = %d, rc = %d",
+				caddy->sender_host, caddy->proc.nspace,
+				caddy->proc.rank, rc);
+		_respond_with_error(seq_num, caddy->sender_host,
+				caddy->sender_ns, rc);
+		_dmdx_free_caddy(caddy);
+	}
+	exit:
+	/* we don't need this buffer anymore */
+	free_buf(buf);
+
+	/* no sense to return errors, engine can't do anything
+	 * anyway. We've notified libpmix, that's enough */
+}
+
+static int _dmdx_req_cmp(void *x, void *key)
+{
+	dmdx_req_info_t *req = (dmdx_req_info_t *)x;
+	uint32_t seq_num = *((uint32_t *)key);
+	return (req->seq_num == seq_num);
+}
+
+static void _dmdx_resp(Buf buf, char *sender_host, uint32_t seq_num)
+{
+	dmdx_req_info_t *req;
+	int rank, rc = SLURM_SUCCESS;
+	int status;
+	char *ns = NULL, *sender_ns = NULL;
+	char *data = NULL;
+	uint32_t size = 0;
+
+	/* find the request tracker */
+	ListIterator it = list_iterator_create(_dmdx_requests);
+	req = (dmdx_req_info_t *)list_find(it, _dmdx_req_cmp, &seq_num);
+	if (NULL == req) {
+		/* We haven't sent this request! */
+		PMIXP_ERROR(
+				"Received DMDX response with bad " "seq_num=%d from %s!",
+				seq_num, sender_host);
+		list_iterator_destroy(it);
+		rc = SLURM_ERROR;
+		goto exit;
+	}
+
+	/* get the service data */
+	if (SLURM_SUCCESS
+			!= (rc = _read_info(buf, &ns, &rank, &sender_ns,
+					&status))) {
+		/* notify libpmix about an error */
+		req->cbfunc(PMIX_ERR_UNPACK_FAILURE, NULL, 0, req->cbdata, NULL,
+				NULL);
+		goto exit;
+	}
+
+	/* get the modex blob */
+	if (SLURM_SUCCESS != (rc = unpackmem_ptr(&data, &size, buf))) {
+		/* notify libpmix about an error */
+		req->cbfunc(PMIX_ERR_UNPACK_FAILURE, NULL, 0, req->cbdata, NULL,
+				NULL);
+		goto exit;
+	}
+
+	/* call back to libpmix-server */
+	req->cbfunc(status, data, size, req->cbdata, pmixp_free_Buf,
+			(void *)buf);
+
+	/* release tracker & list iterator */
+	req = NULL;
+	list_delete_item(it);
+	list_iterator_destroy(it);
+      exit:
+	if (SLURM_SUCCESS != rc) {
+		/* we are not expect libpmix to call the callback
+		 * to cleanup this buffer */
+		free_buf(buf);
+	}
+	/* no sense to return errors, engine can't do anything
+	 * anyway. We've notified libpmix, that's enough */
+}
+
+void pmixp_dmdx_process(Buf buf, char *host, uint32_t seq)
+{
+	dmdx_type_t type;
+	_read_type(buf, &type);
+
+	switch (type) {
+	case DMDX_REQUEST:
+		_dmdx_req(buf, host, seq);
+		break;
+	case DMDX_RESPONSE:
+		_dmdx_resp(buf, host, seq);
+		break;
+	default:
+		PMIXP_ERROR("Bad request from host %s. Skip", host);
+		break;
+	}
+}
+
+void pmixp_dmdx_timeout_cleanup(void)
+{
+	ListIterator it = list_iterator_create(_dmdx_requests);
+	dmdx_req_info_t *req = NULL;
+	time_t ts = time(NULL);
+
+	/* run through all requests and discard stale one's */
+	while (NULL != (req = list_next(it))) {
+		if (ts - req->ts > pmixp_info_timeout()) {
+#ifndef NDEBUG
+			/* respond with the timeout to libpmix */
+			char *host = pmixp_nspace_resolve(req->nspace,
+					req->rank);
+			xassert(NULL != host);
+			PMIXP_ERROR(
+					"timeout: ns=%s, rank=%d," " host=%s, ts=%lu",
+					req->nspace, req->rank,
+					(NULL != host) ? host : "unknown", ts);
+			if (NULL != host) {
+				free(host);
+			}
+#endif
+			req->cbfunc(PMIX_ERR_TIMEOUT, NULL, 0, req->cbdata,
+					NULL, NULL);
+			/* release tracker & list iterator */
+			list_delete_item(it);
+		}
+	}
+	list_iterator_destroy(it);
+}
diff --git a/src/plugins/mpi/pmix/pmixp_dmdx.h b/src/plugins/mpi/pmix/pmixp_dmdx.h
new file mode 100644
index 0000000..2c87ff0
--- /dev/null
+++ b/src/plugins/mpi/pmix/pmixp_dmdx.h
@@ -0,0 +1,51 @@
+/*****************************************************************************\
+ **  pmix_debug.h - PMIx debug primitives
+ *****************************************************************************
+ *  Copyright (C) 2014-2015 Artem Polyakov. All rights reserved.
+ *  Copyright (C) 2015      Mellanox Technologies. All rights reserved.
+ *  Written by Artem Polyakov <artpol84@gmail.com, artemp@mellanox.com>.
+ *
+ *  This file is part of SLURM, a resource management program.
+ *  For details, see <http://slurm.schedmd.com/>.
+ *  Please also read the included file: DISCLAIMER.
+ *
+ *  SLURM is free software; you can redistribute it and/or modify it under
+ *  the terms of the GNU General Public License as published by the Free
+ *  Software Foundation; either version 2 of the License, or (at your option)
+ *  any later version.
+ *
+ *  In addition, as a special exception, the copyright holders give permission
+ *  to link the code of portions of this program with the OpenSSL library under
+ *  certain conditions as described in each individual source file, and
+ *  distribute linked combinations including the two. You must obey the GNU
+ *  General Public License in all respects for all of the code used other than
+ *  OpenSSL. If you modify file(s) with this exception, you may extend this
+ *  exception to your version of the file(s), but you are not obligated to do
+ *  so. If you do not wish to do so, delete this exception statement from your
+ *  version.  If you delete this exception statement from all source files in
+ *  the program, then also delete it here.
+ *
+ *  SLURM is distributed in the hope that it will be useful, but WITHOUT ANY
+ *  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+ *  FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
+ *  details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with SLURM; if not, write to the Free Software Foundation, Inc.,
+ *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA.
+ \*****************************************************************************/
+
+#ifndef PMIXP_DMDX_H
+#define PMIXP_DMDX_H
+
+#include "pmixp_common.h"
+#include "pmixp_nspaces.h"
+
+int pmixp_dmdx_init(void);
+int pmixp_dmdx_finalize(void);
+int pmixp_dmdx_get(const char *nspace, int rank,
+		   pmix_modex_cbfunc_t cbfunc, void *cbdata);
+void pmixp_dmdx_process(Buf buf, char *host, uint32_t seq);
+void pmixp_dmdx_timeout_cleanup(void);
+
+#endif /* PMIXP_DMDX_H */
diff --git a/src/plugins/mpi/pmix/pmixp_info.c b/src/plugins/mpi/pmix/pmixp_info.c
new file mode 100644
index 0000000..4729dc6
--- /dev/null
+++ b/src/plugins/mpi/pmix/pmixp_info.c
@@ -0,0 +1,336 @@
+/*****************************************************************************\
+ **  pmix_info.c - PMIx various environment information
+ *****************************************************************************
+ *  Copyright (C) 2014-2015 Artem Polyakov. All rights reserved.
+ *  Copyright (C) 2015      Mellanox Technologies. All rights reserved.
+ *  Written by Artem Polyakov <artpol84@gmail.com, artemp@mellanox.com>.
+ *
+ *  This file is part of SLURM, a resource management program.
+ *  For details, see <http://slurm.schedmd.com/>.
+ *  Please also read the included file: DISCLAIMER.
+ *
+ *  SLURM is free software; you can redistribute it and/or modify it under
+ *  the terms of the GNU General Public License as published by the Free
+ *  Software Foundation; either version 2 of the License, or (at your option)
+ *  any later version.
+ *
+ *  In addition, as a special exception, the copyright holders give permission
+ *  to link the code of portions of this program with the OpenSSL library under
+ *  certain conditions as described in each individual source file, and
+ *  distribute linked combinations including the two. You must obey the GNU
+ *  General Public License in all respects for all of the code used other than
+ *  OpenSSL. If you modify file(s) with this exception, you may extend this
+ *  exception to your version of the file(s), but you are not obligated to do
+ *  so. If you do not wish to do so, delete this exception statement from your
+ *  version.  If you delete this exception statement from all source files in
+ *  the program, then also delete it here.
+ *
+ *  SLURM is distributed in the hope that it will be useful, but WITHOUT ANY
+ *  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+ *  FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
+ *  details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with SLURM; if not, write to the Free Software Foundation, Inc.,
+ *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA.
+ \*****************************************************************************/
+
+#include <string.h>
+#include "pmixp_common.h"
+#include "pmixp_debug.h"
+#include "pmixp_info.h"
+
+/* Server communication */
+static char *_server_addr = NULL;
+static int _server_fd = -1;
+
+pmix_jobinfo_t _pmixp_job_info = {0};
+
+static int _resources_set(char ***env);
+static int _env_set(char ***env);
+
+/* stepd global contact information */
+void pmixp_info_srv_contacts(char *path, int fd)
+{
+	_server_addr = xstrdup(path);
+	_server_fd = fd;
+}
+
+const char *pmixp_info_srv_addr(void)
+{
+	/* Check that Server address was initialized */
+	xassert(_server_addr != NULL);
+	return _server_addr;
+}
+
+int pmixp_info_srv_fd(void)
+{
+	/* Check that Server fd was created */
+	xassert(_server_fd >= 0);
+	return _server_fd;
+}
+
+int pmixp_info_set(const stepd_step_rec_t *job, char ***env)
+{
+	int i, rc;
+	memset(&_pmixp_job_info, 0, sizeof(_pmixp_job_info));
+#ifndef NDEBUG
+	_pmixp_job_info.magic = PMIX_INFO_MAGIC;
+#endif
+
+	/* This node info */
+	_pmixp_job_info.jobid = job->jobid;
+	_pmixp_job_info.stepid = job->stepid;
+	_pmixp_job_info.node_id = job->nodeid;
+	_pmixp_job_info.node_tasks = job->node_tasks;
+
+	/* Global info */
+	_pmixp_job_info.ntasks = job->ntasks;
+	_pmixp_job_info.nnodes = job->nnodes;
+	_pmixp_job_info.task_cnts = xmalloc(
+			sizeof(*_pmixp_job_info.task_cnts)
+					* _pmixp_job_info.nnodes);
+	for (i = 0; i < _pmixp_job_info.nnodes; i++) {
+		_pmixp_job_info.task_cnts[i] = job->task_cnts[i];
+	}
+
+	_pmixp_job_info.gtids = xmalloc(
+			_pmixp_job_info.node_tasks * sizeof(uint32_t));
+	for (i = 0; i < job->node_tasks; i++) {
+		_pmixp_job_info.gtids[i] = job->task[i]->gtid;
+	}
+
+	/* Setup hostnames and job-wide info */
+	if ((rc = _resources_set(env))) {
+		return rc;
+	}
+
+	if ((rc = _env_set(env))) {
+		return rc;
+	}
+
+	snprintf(_pmixp_job_info.nspace, PMIX_MAX_NSLEN, "slurm.pmix.%d.%d",
+			pmixp_info_jobid(), pmixp_info_stepid());
+
+	return SLURM_SUCCESS;
+}
+
+int pmixp_info_free(void)
+{
+	if (NULL != _pmixp_job_info.task_cnts) {
+		xfree(_pmixp_job_info.task_cnts);
+	}
+	if (NULL != _pmixp_job_info.gtids) {
+		xfree(_pmixp_job_info.gtids);
+	}
+
+	if (NULL != _pmixp_job_info.task_map_packed) {
+		xfree(_pmixp_job_info.task_map_packed);
+	}
+
+	hostlist_destroy(_pmixp_job_info.job_hl);
+	hostlist_destroy(_pmixp_job_info.step_hl);
+	if (NULL != _pmixp_job_info.hostname) {
+		xfree(_pmixp_job_info.hostname);
+	}
+	return SLURM_SUCCESS;
+}
+
+static eio_handle_t *_io_handle = NULL;
+
+void pmixp_info_io_set(eio_handle_t *h)
+{
+	_io_handle = h;
+}
+
+eio_handle_t *pmixp_info_io()
+{
+	xassert(_io_handle != NULL);
+	return _io_handle;
+}
+
+/*
+ * Job and step nodes/tasks count and hostname extraction routines
+ */
+
+/*
+ * Derived from src/srun/libsrun/opt.c
+ * _get_task_count()
+ *
+ * FIXME: original _get_task_count has some additinal ckeck
+ * for opt.ntasks_per_node & opt.cpus_set
+ * Should we care here?
+ static int _get_task_count(char ***env, uint32_t *tasks, uint32_t *cpus)
+ {
+ pmixp_debug_hang(1);
+ char *cpus_per_node = NULL, *cpus_per_task_env = NULL, *end_ptr = NULL;
+ int cpus_per_task = 1, cpu_count, node_count, task_count;
+ int total_tasks = 0, total_cpus = 0;
+
+ cpus_per_node = getenvp(*env, PMIX_CPUS_PER_NODE_ENV);
+ if (cpus_per_node == NULL) {
+ PMIXP_ERROR_NO(0,"Cannot find %s environment variable", PMIX_CPUS_PER_NODE_ENV);
+ return SLURM_ERROR;
+ }
+ cpus_per_task_env = getenvp(*env, PMIX_CPUS_PER_TASK);
+ if (cpus_per_task_env != NULL) {
+ cpus_per_task = strtol(cpus_per_task_env, &end_ptr, 10);
+ }
+
+ cpu_count = strtol(cpus_per_node, &end_ptr, 10);
+ task_count = cpu_count / cpus_per_task;
+ while (1) {
+ if ((end_ptr[0] == '(') && (end_ptr[1] == 'x')) {
+ end_ptr += 2;
+ node_count = strtol(end_ptr, &end_ptr, 10);
+ task_count *= node_count;
+ total_tasks += task_count;
+ cpu_count *= node_count;
+ total_cpus += cpu_count;
+ if (end_ptr[0] == ')')
+ end_ptr++;
+ } else if ((end_ptr[0] == ',') || (end_ptr[0] == 0))
+ total_tasks += task_count;
+ else {
+ PMIXP_ERROR_NO(0,"Invalid value for environment variable %s (%s)",
+ PMIX_CPUS_PER_NODE_ENV, cpus_per_node);
+ return SLURM_ERROR;
+ }
+ if (end_ptr[0] == ',')
+ end_ptr++;
+ if (end_ptr[0] == 0)
+ break;
+ }
+ *tasks = total_tasks;
+ *cpus = total_cpus;
+ return 0;
+ }
+ */
+
+static int _resources_set(char ***env)
+{
+	char *p = NULL;
+
+	/* Initialize all memory pointers that would be allocated to NULL
+	 * So in case of error exit we will know what to xfree
+	 */
+	_pmixp_job_info.job_hl = hostlist_create("");
+	_pmixp_job_info.step_hl = hostlist_create("");
+	_pmixp_job_info.hostname = NULL;
+
+	/* Save step host list */
+	p = getenvp(*env, PMIXP_STEP_NODES_ENV);
+	if (!p) {
+		PMIXP_ERROR_NO(ENOENT, "Environment variable %s not found",
+				PMIXP_STEP_NODES_ENV);
+		goto err_exit;
+	}
+	hostlist_push(_pmixp_job_info.step_hl, p);
+
+	/* Extract our node name */
+	p = hostlist_nth(_pmixp_job_info.step_hl, _pmixp_job_info.node_id);
+	_pmixp_job_info.hostname = xstrdup(p);
+	free(p);
+
+	/* Determine job-wide node id and job-wide node count */
+	p = getenvp(*env, PMIXP_JOB_NODES_ENV);
+	if (p == NULL) {
+		/* shouldn't happen if we are under SLURM! */
+		PMIXP_ERROR_NO(ENOENT, "No %s environment variable found!",
+				PMIXP_JOB_NODES_ENV);
+		goto err_exit;
+	}
+	hostlist_push(_pmixp_job_info.job_hl, p);
+	_pmixp_job_info.nnodes_job = hostlist_count(_pmixp_job_info.job_hl);
+	_pmixp_job_info.node_id_job = hostlist_find(_pmixp_job_info.job_hl,
+			_pmixp_job_info.hostname);
+
+	/* FIXME!! ------------------------------------------------------------- */
+	/* TODO: _get_task_count not always works well.
+	 if (_get_task_count(env, &_pmixp_job_info.ntasks_job, &_pmixp_job_info.ncpus_job) < 0) {
+	 _pmixp_job_info.ntasks_job  = _pmixp_job_info.ntasks;
+	 _pmixp_job_info.ncpus_job  = _pmixp_job_info.ntasks;
+	 }
+	 xassert(_pmixp_job_info.ntasks <= _pmixp_job_info.ntasks_job);
+	 */
+	_pmixp_job_info.ntasks_job = _pmixp_job_info.ntasks;
+	_pmixp_job_info.ncpus_job = _pmixp_job_info.ntasks;
+
+	/* Save task-to-node mapping */
+	p = getenvp(*env, PMIXP_SLURM_MAPPING_ENV);
+	if (p == NULL) {
+		/* Direct modex won't work */
+		PMIXP_ERROR_NO(ENOENT, "No %s environment variable found!",
+				PMIXP_SLURM_MAPPING_ENV);
+		goto err_exit;
+	}
+
+	_pmixp_job_info.task_map_packed = xstrdup(p);
+
+	return SLURM_SUCCESS;
+      err_exit:
+	hostlist_destroy(_pmixp_job_info.job_hl);
+	hostlist_destroy(_pmixp_job_info.step_hl);
+	if (NULL != _pmixp_job_info.hostname) {
+		xfree(_pmixp_job_info.hostname);
+	}
+	return SLURM_ERROR;
+}
+
+static int _env_set(char ***env)
+{
+	char *p = NULL;
+
+	/* ----------- Temp directories settings ------------- */
+	/* set server temp directory - change
+	 * this process environment */
+	p = getenvp(*env, PMIXP_TMPDIR_SRV);
+	if (NULL != p) {
+		setenv(PMIXP_OS_TMPDIR_ENV, p, 1);
+	}
+
+	p = getenv(PMIXP_OS_TMPDIR_ENV);
+	if (NULL == p) {
+		p = PMIXP_TMPDIR_DEFAULT;
+	}
+	_pmixp_job_info.lib_tmpdir = xstrdup_printf("%s/pmix.%d.%d/", p,
+			pmixp_info_jobid(), pmixp_info_stepid());
+
+	/* save client temp directory if requested
+	 * TODO: We want to get TmpFS value as well if exists.
+	 * Need to sync with SLURM developers.
+	 */
+	p = getenvp(*env, PMIXP_TMPDIR_CLI);
+	if (NULL != p) {
+		_pmixp_job_info.cli_tmpdir = xstrdup(p);
+	} else {
+		p = slurm_get_tmp_fs();
+		if (NULL != p) {
+			_pmixp_job_info.cli_tmpdir = p;
+		}
+	}
+
+	/* ----------- Timeout setting ------------- */
+	/* TODO: also would be nice to have a cluster-wide setting in SLURM */
+	_pmixp_job_info.timeout = PMIXP_TIMEOUT_DEFAULT;
+	p = getenvp(*env, PMIXP_TIMEOUT);
+	if (NULL != p) {
+		int tmp;
+		tmp = atoi(p);
+		if (tmp > 0) {
+			_pmixp_job_info.timeout = tmp;
+		}
+	}
+
+	/* ----------- Forward PMIX settings ------------- */
+	p = getenvp(*env, PMIXP_TIMEOUT);
+	if (NULL != p) {
+		setenv("PMIX_DEBUG", p, 1);
+		/* output into the file since we are in slurmstepd
+		 * and stdout is muted.
+		 * One needs to check TMPDIR for the results */
+		setenv("PMIX_OUTPUT_REDIRECT", "file", 1);
+	}
+
+	return SLURM_SUCCESS;
+}
diff --git a/src/plugins/mpi/pmix/pmixp_info.h b/src/plugins/mpi/pmix/pmixp_info.h
new file mode 100644
index 0000000..69d0df0
--- /dev/null
+++ b/src/plugins/mpi/pmix/pmixp_info.h
@@ -0,0 +1,269 @@
+/*****************************************************************************\
+ **  pmix_info.h - PMIx various environment information
+ *****************************************************************************
+ *  Copyright (C) 2014-2015 Artem Polyakov. All rights reserved.
+ *  Copyright (C) 2015      Mellanox Technologies. All rights reserved.
+ *  Written by Artem Polyakov <artpol84@gmail.com, artemp@mellanox.com>.
+ *
+ *  This file is part of SLURM, a resource management program.
+ *  For details, see <http://slurm.schedmd.com/>.
+ *  Please also read the included file: DISCLAIMER.
+ *
+ *  SLURM is free software; you can redistribute it and/or modify it under
+ *  the terms of the GNU General Public License as published by the Free
+ *  Software Foundation; either version 2 of the License, or (at your option)
+ *  any later version.
+ *
+ *  In addition, as a special exception, the copyright holders give permission
+ *  to link the code of portions of this program with the OpenSSL library under
+ *  certain conditions as described in each individual source file, and
+ *  distribute linked combinations including the two. You must obey the GNU
+ *  General Public License in all respects for all of the code used other than
+ *  OpenSSL. If you modify file(s) with this exception, you may extend this
+ *  exception to your version of the file(s), but you are not obligated to do
+ *  so. If you do not wish to do so, delete this exception statement from your
+ *  version.  If you delete this exception statement from all source files in
+ *  the program, then also delete it here.
+ *
+ *  SLURM is distributed in the hope that it will be useful, but WITHOUT ANY
+ *  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+ *  FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
+ *  details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with SLURM; if not, write to the Free Software Foundation, Inc.,
+ *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA.
+ \*****************************************************************************/
+
+#ifndef PMIXP_INFO_H
+#define PMIXP_INFO_H
+
+#include "pmixp_common.h"
+
+/*
+ *  Slurm job and job-step information
+ */
+
+typedef struct {
+#ifndef NDEBUG
+#define PMIX_INFO_MAGIC 0xCAFEFACE
+	int magic;
+#endif
+	char nspace[PMIX_MAX_NSLEN];
+	uint32_t jobid; /* Current SLURM job id                         */
+	uint32_t stepid; /* Current step id (or NO_VAL)                  */
+	uint32_t nnodes; /* number of nodes in current step              */
+	uint32_t nnodes_job; /* number of nodes in current job               */
+	uint32_t ntasks; /* total number of tasks in current step        */
+	uint32_t ntasks_job; /* total possible number of tasks in job        */
+	uint32_t ncpus_job; /* total possible number of cpus in job         */
+	uint32_t *task_cnts; /* Number of tasks on each node in this step    */
+	int node_id; /* relative position of this node in this step  */
+	int node_id_job; /* relative position of this node in SLURM job  */
+	hostlist_t job_hl;
+	hostlist_t step_hl;
+	char *hostname;
+	uint32_t node_tasks; /* number of tasks on *this* node               */
+	uint32_t *gtids; /* global ids of tasks located on *this* node   */
+	char *task_map_packed; /* string represents packed task mapping information */
+	int timeout;
+	char *cli_tmpdir;
+	char *lib_tmpdir;
+} pmix_jobinfo_t;
+
+extern pmix_jobinfo_t _pmixp_job_info;
+
+/* slurmd contact information */
+void pmixp_info_srv_contacts(char *path, int fd);
+const char *pmixp_info_srv_addr(void);
+int pmixp_info_srv_fd(void);
+
+static inline int pmixp_info_timeout(void)
+{
+	xassert(_pmixp_job_info.magic == PMIX_INFO_MAGIC);
+	return _pmixp_job_info.timeout;
+}
+
+/* My hostname */
+static inline char *pmixp_info_hostname(void)
+{
+	return _pmixp_job_info.hostname;
+}
+
+/* Cli tempdir */
+static inline char *pmixp_info_tmpdir_cli(void)
+{
+	return _pmixp_job_info.cli_tmpdir;
+}
+
+/* Cli tempdir */
+static inline char *pmixp_info_tmpdir_lib(void)
+{
+	return _pmixp_job_info.lib_tmpdir;
+}
+
+/* Dealing with I/O */
+void pmixp_info_io_set(eio_handle_t *h);
+eio_handle_t *pmixp_info_io();
+
+/* Job information */
+int pmixp_info_set(const stepd_step_rec_t *job, char ***env);
+int pmixp_info_free(void);
+
+static inline uint32_t pmixp_info_jobid(void)
+{
+	xassert(_pmixp_job_info.magic == PMIX_INFO_MAGIC);
+	return _pmixp_job_info.jobid;
+}
+
+static inline uint32_t pmixp_info_stepid(void)
+{
+	xassert(_pmixp_job_info.magic == PMIX_INFO_MAGIC);
+	return _pmixp_job_info.stepid;
+}
+
+static inline char *pmixp_info_namespace(void)
+{
+	xassert(_pmixp_job_info.magic == PMIX_INFO_MAGIC);
+	return _pmixp_job_info.nspace;
+}
+
+static inline uint32_t pmixp_info_nodeid(void)
+{
+	/* This routine is called from PMIX_DEBUG/ERROR and
+	 * this CAN happen before initialization. Relax demand to have
+	 * _pmix_job_info.magic == PMIX_INFO_MAGIC
+	 * ! xassert(_pmix_job_info.magic == PMIX_INFO_MAGIC);
+	 */
+	return _pmixp_job_info.node_id;
+}
+
+static inline uint32_t pmixp_info_nodeid_job(void)
+{
+	/* This routine is called from PMIX_DEBUG/ERROR and
+	 * this CAN happen before initialization. Relax demand to have
+	 * _pmix_job_info.magic == PMIX_INFO_MAGIC
+	 * ! xassert(_pmix_job_info.magic == PMIX_INFO_MAGIC);
+	 */
+	return _pmixp_job_info.node_id_job;
+}
+
+static inline uint32_t pmixp_info_nodes(void)
+{
+	xassert(_pmixp_job_info.magic == PMIX_INFO_MAGIC);
+	return _pmixp_job_info.nnodes;
+}
+
+static inline uint32_t pmixp_info_nodes_uni(void)
+{
+	xassert(_pmixp_job_info.magic == PMIX_INFO_MAGIC);
+	return _pmixp_job_info.nnodes_job;
+}
+
+static inline uint32_t pmixp_info_tasks(void)
+{
+	xassert(_pmixp_job_info.magic == PMIX_INFO_MAGIC);
+	return _pmixp_job_info.ntasks;
+}
+
+static inline uint32_t pmixp_info_tasks_node(uint32_t nodeid)
+{
+	xassert(_pmixp_job_info.magic == PMIX_INFO_MAGIC);
+	xassert(nodeid < _pmixp_job_info.nnodes);
+	return _pmixp_job_info.task_cnts[nodeid];
+}
+
+static inline uint32_t *pmixp_info_tasks_cnts(void)
+{
+	xassert(_pmixp_job_info.magic == PMIX_INFO_MAGIC);
+	return _pmixp_job_info.task_cnts;
+}
+
+static inline uint32_t pmixp_info_tasks_loc(void)
+{
+	xassert(_pmixp_job_info.magic == PMIX_INFO_MAGIC);
+	return _pmixp_job_info.node_tasks;
+}
+
+static inline uint32_t pmixp_info_tasks_uni(void)
+{
+	xassert(_pmixp_job_info.magic == PMIX_INFO_MAGIC);
+	return _pmixp_job_info.ntasks_job;
+}
+
+static inline uint32_t pmixp_info_cpus(void)
+{
+	xassert(_pmixp_job_info.magic == PMIX_INFO_MAGIC);
+	return _pmixp_job_info.ncpus_job;
+}
+
+static inline uint32_t pmixp_info_taskid(uint32_t localid)
+{
+	xassert(_pmixp_job_info.magic == PMIX_INFO_MAGIC);
+	xassert(localid < _pmixp_job_info.node_tasks);
+	return _pmixp_job_info.gtids[localid];
+}
+
+/*
+ * Since tasks array in SLURM job structure is uint16_t
+ * task local id can't be grater than 2^16. So we can
+ * safely return int here. We need (-1) for the not-found case
+ */
+static inline int pmixp_info_taskid2localid(uint32_t taskid)
+{
+	int i;
+	xassert(_pmixp_job_info.magic == PMIX_INFO_MAGIC);
+	xassert(taskid < _pmixp_job_info.ntasks);
+
+	for (i = 0; i < _pmixp_job_info.node_tasks; i++) {
+		if (_pmixp_job_info.gtids[i] == taskid)
+			return i;
+	}
+	return -1;
+}
+
+static inline char *pmixp_info_task_map(void)
+{
+	return _pmixp_job_info.task_map_packed;
+}
+
+static inline hostlist_t pmixp_info_step_hostlist(void)
+{
+	return _pmixp_job_info.step_hl;
+}
+
+static inline char *pmixp_info_step_host(int nodeid)
+{
+	xassert(nodeid < _pmixp_job_info.nnodes);
+	char *p = hostlist_nth(_pmixp_job_info.step_hl, nodeid);
+	char *ret = xstrdup(p);
+	free(p);
+	return ret;
+}
+
+static inline char *pmixp_info_job_host(int nodeid)
+{
+	xassert(nodeid < _pmixp_job_info.nnodes_job);
+	char *p = hostlist_nth(_pmixp_job_info.job_hl, nodeid);
+	char *ret = xstrdup(p);
+	free(p);
+	return ret;
+}
+
+/* namespaces list operations */
+static inline char *pmixp_info_nspace_usock(const char *nspace)
+{
+	char *usock = NULL;
+	/* TODO: provide the right way to set this:
+	 * - slrum.conf
+	 * - what else?
+	 */
+	char *tmpdir = getenv("TMPDIR");
+	if (NULL == tmpdir) {
+		tmpdir = PMIXP_TMPDIR_DEFAULT;
+	}
+	xstrfmtcat(usock, "%s/sock.stepd.%s", tmpdir, nspace);
+	return usock;
+}
+
+#endif /* PMIXP_INFO_H */
diff --git a/src/plugins/mpi/pmix/pmixp_io.c b/src/plugins/mpi/pmix/pmixp_io.c
new file mode 100644
index 0000000..e2e230b
--- /dev/null
+++ b/src/plugins/mpi/pmix/pmixp_io.c
@@ -0,0 +1,448 @@
+/*****************************************************************************\
+ **  pmix_io.c - PMIx non-blocking IO routines
+ *****************************************************************************
+ *  Copyright (C) 2014-2015 Artem Polyakov. All rights reserved.
+ *  Copyright (C) 2015      Mellanox Technologies. All rights reserved.
+ *  Written by Artem Polyakov <artpol84@gmail.com, artemp@mellanox.com>.
+ *
+ *  This file is part of SLURM, a resource management program.
+ *  For details, see <http://slurm.schedmd.com/>.
+ *  Please also read the included file: DISCLAIMER.
+ *
+ *  SLURM is free software; you can redistribute it and/or modify it under
+ *  the terms of the GNU General Public License as published by the Free
+ *  Software Foundation; either version 2 of the License, or (at your option)
+ *  any later version.
+ *
+ *  In addition, as a special exception, the copyright holders give permission
+ *  to link the code of portions of this program with the OpenSSL library under
+ *  certain conditions as described in each individual source file, and
+ *  distribute linked combinations including the two. You must obey the GNU
+ *  General Public License in all respects for all of the code used other than
+ *  OpenSSL. If you modify file(s) with this exception, you may extend this
+ *  exception to your version of the file(s), but you are not obligated to do
+ *  so. If you do not wish to do so, delete this exception statement from your
+ *  version.  If you delete this exception statement from all source files in
+ *  the program, then also delete it here.
+ *
+ *  SLURM is distributed in the hope that it will be useful, but WITHOUT ANY
+ *  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+ *  FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
+ *  details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with SLURM; if not, write to the Free Software Foundation, Inc.,
+ *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA.
+ \*****************************************************************************/
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <sys/un.h>
+#include <errno.h>
+
+#include "pmixp_common.h"
+#include "pmixp_io.h"
+#include "pmixp_debug.h"
+#include "pmixp_utils.h"
+
+void pmix_io_init(pmixp_io_engine_t *eng, int fd,
+		pmixp_io_engine_header_t header)
+{
+	/* Initialize general options */
+#ifndef NDEBUG
+	eng->magic = PMIX_MSGSTATE_MAGIC;
+#endif
+	eng->error = 0;
+	eng->sd = fd;
+	eng->header = header;
+	eng->operating = true;
+
+	if (header.pack_hdr_cb == NULL && header.unpack_hdr_cb == NULL) {
+		xassert(header.host_size == header.net_size);
+	}
+	/* Init receiver */
+	eng->rcvd_hdr = xmalloc(eng->header.net_size);
+	if (eng->header.unpack_hdr_cb) {
+		eng->rcvd_hdr_host = xmalloc(eng->header.host_size);
+	} else {
+		eng->rcvd_hdr_host = eng->rcvd_hdr;
+	}
+
+	eng->rcvd_pay_size = 0;
+	eng->rcvd_payload = NULL;
+	eng->rcvd_hdr_offs = eng->rcvd_pay_offs = 0;
+	eng->rcvd_padding = 0;
+	/* Init transmitter */
+	eng->send_current = NULL;
+	if (eng->header.pack_hdr_cb) {
+		eng->send_hdr_net = xmalloc(eng->header.net_size);
+	}
+	eng->send_hdr_size = eng->send_hdr_offs = 0;
+	eng->send_payload = NULL;
+	eng->send_pay_size = eng->send_pay_offs = 0;
+	eng->send_queue = list_create(pmixp_xfree_xmalloced);
+}
+
+void pmix_io_finalize(pmixp_io_engine_t *eng, int error)
+{
+	if (!eng->operating) {
+		return;
+	}
+	eng->operating = false;
+
+	/* Free transmitter */
+	if (list_count(eng->send_queue)) {
+		list_destroy(eng->send_queue);
+	}
+	if (NULL != eng->send_current) {
+		xfree(eng->send_current);
+	}
+	eng->send_current = NULL;
+	eng->send_payload = NULL;
+	eng->send_pay_size = eng->send_pay_offs = 0;
+	if (eng->header.pack_hdr_cb) {
+		xfree(eng->send_hdr_net);
+	}
+	eng->send_hdr_size = eng->send_hdr_offs = 0;
+
+	/* Free receiver */
+	if (NULL != eng->rcvd_payload) {
+		xfree(eng->rcvd_payload);
+	}
+
+	xfree(eng->rcvd_hdr);
+	if (eng->header.unpack_hdr_cb) {
+		xfree(eng->rcvd_hdr_host);
+	}
+	eng->rcvd_hdr = NULL;
+	eng->rcvd_hdr_host = NULL;
+
+	eng->rcvd_pay_size = 0;
+	eng->rcvd_payload = NULL;
+	eng->rcvd_hdr_offs = eng->rcvd_pay_offs = 0;
+
+	if (error < 0) {
+		eng->error = -error;
+	} else {
+		eng->error = 0;
+	}
+}
+
+/* Receiver */
+
+int pmix_io_first_header(int fd, void *buf, uint32_t *_offs, uint32_t len)
+{
+	int shutdown;
+	uint32_t offs = *_offs;
+
+	offs += pmixp_read_buf(fd, buf + offs, len, &shutdown, true);
+	*_offs = offs;
+	if (shutdown) {
+		if (shutdown < 0) {
+			PMIXP_ERROR_NO(shutdown, "Unexpected connection close");
+		} else {
+			PMIXP_DEBUG("Unexpected connection close");
+		}
+		return SLURM_ERROR;
+	}
+	return 0;
+}
+
+static inline void _rcvd_next_message(pmixp_io_engine_t *eng)
+{
+	xassert(eng->magic == PMIX_MSGSTATE_MAGIC);
+	xassert(eng->rcvd_hdr != NULL);
+	xassert(eng->operating);
+
+	eng->rcvd_pad_recvd = 0;
+	eng->rcvd_hdr_offs = 0;
+	eng->rcvd_pay_offs = eng->rcvd_pay_size = 0;
+	eng->rcvd_payload = NULL;
+
+}
+
+static inline int _rcvd_swithch_to_body(pmixp_io_engine_t *eng)
+{
+	int rc;
+	xassert(eng->magic == PMIX_MSGSTATE_MAGIC);
+	xassert(eng->operating);
+	xassert(eng->header.net_size == eng->rcvd_hdr_offs);
+
+	eng->rcvd_pay_offs = eng->rcvd_pay_size = 0;
+	eng->rcvd_payload = NULL;
+	if (eng->header.unpack_hdr_cb) {
+		/* If this is inter-node communication - unpack the buffer first */
+		if ((rc = eng->header.unpack_hdr_cb(eng->rcvd_hdr,
+				eng->rcvd_hdr_host))) {
+			PMIXP_ERROR_NO(rc, "Cannot unpack message header");
+			return rc;
+		}
+	}
+	eng->rcvd_pay_size = eng->header.pay_size_cb(eng->rcvd_hdr_host);
+	eng->rcvd_payload = xmalloc(eng->rcvd_pay_size);
+	return 0;
+}
+
+static inline bool _rcvd_have_padding(pmixp_io_engine_t *eng)
+{
+	return eng->rcvd_padding && eng->rcvd_pad_recvd < eng->rcvd_padding;
+}
+
+static inline bool _rcvd_need_header(pmixp_io_engine_t *eng)
+{
+	return eng->rcvd_hdr_offs < eng->header.net_size;
+}
+
+void pmix_io_rcvd(pmixp_io_engine_t *eng)
+{
+	size_t size, remain;
+	void *offs;
+	int shutdown;
+	int fd = eng->sd;
+
+	xassert(eng->magic == PMIX_MSGSTATE_MAGIC);
+
+	if (pmix_io_finalized(eng)) {
+		return;
+	}
+
+	if (pmix_io_rcvd_ready(eng)) {
+		/* nothing to do,
+		 * first the current message has to be extracted
+		 */
+		return;
+	}
+	/* Drop padding first so it won't corrupt the message */
+	if (_rcvd_have_padding(eng)) {
+		char buf[eng->rcvd_padding];
+		size = eng->rcvd_padding;
+		remain = size - eng->rcvd_pad_recvd;
+		eng->rcvd_pad_recvd +=
+			pmixp_read_buf(fd, buf, remain, &shutdown, false);
+		if (shutdown) {
+			pmix_io_finalize(eng, 0);
+			return;
+		}
+		if (eng->rcvd_pad_recvd < size) {
+			/* normal return. receive another portion of header later */
+			return;
+		}
+	}
+
+	if (_rcvd_need_header(eng)) {
+		/* need to finish with the header */
+		size = eng->header.net_size;
+		remain = size - eng->rcvd_hdr_offs;
+		offs = eng->rcvd_hdr + eng->rcvd_hdr_offs;
+		eng->rcvd_hdr_offs +=
+			pmixp_read_buf(fd, offs, remain, &shutdown, false);
+		if (shutdown) {
+			pmix_io_finalize(eng, shutdown);
+			return;
+		}
+		if (eng->rcvd_hdr_offs < size) {
+			/* normal return. receive another portion of header later */
+			return;
+		}
+		/* if we are here then header is received and we can adjust buffer */
+		if ((shutdown = _rcvd_swithch_to_body(eng))) {
+			pmix_io_finalize(eng, shutdown);
+			return;
+		}
+		/* go ahared with body receive */
+	}
+	/* we are receiving the body */
+	xassert(eng->rcvd_hdr_offs == eng->header.net_size);
+	if (eng->rcvd_pay_size == 0) {
+		/* zero-byte message. exit. next time we will hit pmix_nbmsg_rcvd_ready */
+		return;
+	}
+	size = eng->rcvd_pay_size;
+	remain = size - eng->rcvd_pay_offs;
+	eng->rcvd_pay_offs +=
+		pmixp_read_buf(fd, eng->rcvd_payload + eng->rcvd_pay_offs,
+			remain, &shutdown, false);
+	if (shutdown) {
+		pmix_io_finalize(eng, 0);
+		return;
+	}
+	if (eng->rcvd_pay_offs == size) {
+		/* normal return. receive another portion later */
+		PMIXP_DEBUG("Message is ready for processing!");
+		return;
+	}
+
+}
+
+void *pmix_io_rcvd_extract(pmixp_io_engine_t *eng, void *header)
+{
+	xassert(eng->magic == PMIX_MSGSTATE_MAGIC);
+	xassert(eng->operating);
+	xassert(pmix_io_rcvd_ready(eng));
+
+	void *ptr = eng->rcvd_payload;
+	memcpy(header, eng->rcvd_hdr_host, (size_t)eng->header.host_size);
+	/* Drop message state to receive new one */
+	_rcvd_next_message(eng);
+	return ptr;
+}
+
+/* Transmitter */
+
+static inline int _send_set_current(pmixp_io_engine_t *eng, void *msg)
+{
+	xassert(eng->magic == PMIX_MSGSTATE_MAGIC);
+	xassert(eng->operating);
+
+	/* Set message basis */
+	eng->send_current = msg;
+
+	/* Setup header for sending */
+	if (eng->header.pack_hdr_cb) {
+		eng->send_hdr_size =
+			eng->header.pack_hdr_cb(msg, eng->send_hdr_net);
+		xassert(eng->send_hdr_size > 0);
+	} else {
+		eng->send_hdr_net = msg;
+		eng->send_hdr_size = eng->header.net_size;
+	}
+	eng->send_hdr_offs = 0;
+
+	/* Setup payload for sending */
+	eng->send_payload = (char *)msg + eng->header.host_size;
+	eng->send_pay_size = eng->header.pay_size_cb(msg);
+	eng->send_pay_offs = 0;
+	return 0;
+}
+
+static inline void _send_free_current(pmixp_io_engine_t *eng)
+{
+	xassert(eng->magic == PMIX_MSGSTATE_MAGIC);
+	xassert(eng->operating);
+	xassert(eng->send_current);
+
+	eng->send_payload = NULL;
+	eng->send_pay_size = eng->send_pay_offs = 0;
+
+	if (eng->header.pack_hdr_cb == NULL) {
+		eng->send_hdr_net = NULL;
+	}
+	eng->send_hdr_size = eng->send_hdr_offs = 0;
+	xfree(eng->send_current);
+	eng->send_current = NULL;
+}
+
+static inline int _send_header_ok(pmixp_io_engine_t *eng)
+{
+	xassert(eng->magic == PMIX_MSGSTATE_MAGIC);
+	xassert(eng->operating);
+	xassert(eng->send_current != NULL);
+
+	return (eng->send_current != NULL) && (eng->send_hdr_size > 0)
+			&& (eng->send_hdr_offs == eng->send_hdr_size);
+}
+
+static inline int _send_payload_ok(pmixp_io_engine_t *eng)
+{
+	xassert(eng->magic == PMIX_MSGSTATE_MAGIC);
+	xassert(eng->operating);
+
+	return (eng->send_current != NULL) && _send_header_ok(eng)
+			&& (eng->send_pay_size > 0)
+			&& (eng->send_pay_offs == eng->send_pay_size);
+}
+
+void pmix_io_send_enqueue(pmixp_io_engine_t *eng, void *msg)
+{
+	xassert(eng->magic == PMIX_MSGSTATE_MAGIC);
+	xassert(eng->operating);
+	if (eng->send_current == NULL) {
+		_send_set_current(eng, msg);
+	} else {
+		list_enqueue(eng->send_queue, msg);
+	}
+	pmix_io_send_progress(eng);
+}
+
+bool pmix_io_send_pending(pmixp_io_engine_t *eng)
+{
+	int rc;
+
+	xassert(eng->magic == PMIX_MSGSTATE_MAGIC);
+	xassert(eng->operating);
+
+	if (_send_payload_ok(eng)) {
+		/* The current message is send. Cleanup current msg */
+		_send_free_current(eng);
+	}
+
+	if (eng->send_current == NULL) {
+		/* Try next element */
+		int n = list_count(eng->send_queue);
+		if (n == 0) {
+			/* Nothing to do */
+			return false;
+		}
+		void *msg = list_dequeue(eng->send_queue);
+		xassert(msg != NULL);
+		if ((rc = _send_set_current(eng, msg))) {
+			PMIXP_ERROR_NO(rc, "Cannot switch to the next message");
+			pmix_io_finalize(eng, rc);
+		}
+	}
+	return true;
+}
+
+void pmix_io_send_progress(pmixp_io_engine_t *eng)
+{
+	int fd = eng->sd;
+	uint32_t size, remain;
+	void *offs;
+
+	xassert(eng->magic == PMIX_MSGSTATE_MAGIC);
+	xassert(eng->operating);
+
+	while (pmix_io_send_pending(eng)) {
+		/* try to send everything untill fd became blockable
+		 * FIXME: maybe set some restriction on number of messages sended at once
+		 */
+		int shutdown = 0;
+		if (!_send_header_ok(eng)) {
+			size = eng->send_hdr_size;
+			remain = size - eng->send_hdr_offs;
+			offs = eng->send_hdr_net + eng->send_hdr_offs;
+			int cnt = pmixp_write_buf(fd, offs, remain, &shutdown,
+					false);
+			if (shutdown) {
+				pmix_io_finalize(eng, shutdown);
+				return;
+			}
+			if (cnt == 0) {
+				break;
+			}
+			eng->send_hdr_offs += cnt;
+			if (!_send_header_ok(eng)) {
+				/* Go to the next interation and try to finish header reception */
+				continue;
+			}
+		}
+
+		if (_send_header_ok(eng)) {
+			size = eng->send_pay_size;
+			remain = size - eng->send_pay_offs;
+			offs = eng->send_payload + eng->send_pay_offs;
+			int cnt = pmixp_write_buf(fd, offs, remain, &shutdown,
+					false);
+			if (shutdown) {
+				pmix_io_finalize(eng, shutdown);
+				return;
+			}
+			if (cnt == 0) {
+				break;
+			}
+			eng->send_pay_offs += cnt;
+		}
+	}
+}
diff --git a/src/plugins/mpi/pmix/pmixp_io.h b/src/plugins/mpi/pmix/pmixp_io.h
new file mode 100644
index 0000000..d5f5cc0
--- /dev/null
+++ b/src/plugins/mpi/pmix/pmixp_io.h
@@ -0,0 +1,126 @@
+/*****************************************************************************\
+ **  pmix_io.h - PMIx non-blocking IO routines
+ *****************************************************************************
+ *  Copyright (C) 2014-2015 Artem Polyakov. All rights reserved.
+ *  Copyright (C) 2015      Mellanox Technologies. All rights reserved.
+ *  Written by Artem Polyakov <artpol84@gmail.com, artemp@mellanox.com>.
+ *
+ *  This file is part of SLURM, a resource management program.
+ *  For details, see <http://slurm.schedmd.com/>.
+ *  Please also read the included file: DISCLAIMER.
+ *
+ *  SLURM is free software; you can redistribute it and/or modify it under
+ *  the terms of the GNU General Public License as published by the Free
+ *  Software Foundation; either version 2 of the License, or (at your option)
+ *  any later version.
+ *
+ *  In addition, as a special exception, the copyright holders give permission
+ *  to link the code of portions of this program with the OpenSSL library under
+ *  certain conditions as described in each individual source file, and
+ *  distribute linked combinations including the two. You must obey the GNU
+ *  General Public License in all respects for all of the code used other than
+ *  OpenSSL. If you modify file(s) with this exception, you may extend this
+ *  exception to your version of the file(s), but you are not obligated to do
+ *  so. If you do not wish to do so, delete this exception statement from your
+ *  version.  If you delete this exception statement from all source files in
+ *  the program, then also delete it here.
+ *
+ *  SLURM is distributed in the hope that it will be useful, but WITHOUT ANY
+ *  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+ *  FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
+ *  details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with SLURM; if not, write to the Free Software Foundation, Inc.,
+ *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA.
+ \*****************************************************************************/
+
+#ifndef PMIXP_IO_H
+#define PMIXP_IO_H
+
+#include <poll.h>
+#include "pmixp_common.h"
+#include "pmixp_utils.h"
+
+/* Message management */
+
+typedef uint32_t (*pmix_io_engine_hsize_cb_t)(void *hdr);
+typedef int (*pmix_io_engine_hpack_cb_t)(void *hdr_host, void *hdr_net);
+typedef int (*pmix_io_engine_hunpack_cb_t)(void *hdr_net, void *hdr_host);
+typedef struct {
+	uint32_t host_size, net_size;
+	pmix_io_engine_hpack_cb_t pack_hdr_cb;
+	pmix_io_engine_hunpack_cb_t unpack_hdr_cb;
+	pmix_io_engine_hsize_cb_t pay_size_cb;
+} pmixp_io_engine_header_t;
+
+typedef struct {
+#ifndef NDEBUG
+#define PMIX_MSGSTATE_MAGIC 0xC0FFEEEE
+	int magic;
+#endif
+	/* User supplied information */
+	int sd;
+	int error;
+	pmixp_io_engine_header_t header;
+	bool operating;
+	/* receiver */
+	uint32_t rcvd_hdr_offs;
+	void *rcvd_hdr;
+	void *rcvd_hdr_host;
+	uint32_t rcvd_pay_size;
+	uint32_t rcvd_pay_offs;
+	void *rcvd_payload;
+	uint32_t rcvd_padding;
+	uint32_t rcvd_pad_recvd;
+	/* sender */
+	void *send_current;
+	void *send_hdr_net;
+	uint32_t send_hdr_offs;
+	uint32_t send_hdr_size;
+	void *send_payload;
+	uint32_t send_pay_offs;
+	uint32_t send_pay_size;
+	List send_queue;
+} pmixp_io_engine_t;
+
+static inline void pmix_io_rcvd_padding(pmixp_io_engine_t *eng,
+		uint32_t padsize)
+{
+	xassert(eng->magic == PMIX_MSGSTATE_MAGIC);
+	eng->rcvd_padding = padsize;
+}
+
+static inline bool pmix_io_rcvd_ready(pmixp_io_engine_t *eng)
+{
+	xassert(eng->magic == PMIX_MSGSTATE_MAGIC);
+	return (eng->rcvd_hdr_offs == eng->header.net_size)
+			&& (eng->rcvd_pay_size == eng->rcvd_pay_offs);
+}
+
+static inline bool pmix_io_finalized(pmixp_io_engine_t *eng)
+{
+	xassert(eng->magic == PMIX_MSGSTATE_MAGIC);
+	return !(eng->operating);
+}
+
+static inline int pmix_io_error(pmixp_io_engine_t *eng)
+{
+	xassert(eng->magic == PMIX_MSGSTATE_MAGIC);
+	return eng->error;
+}
+
+void pmix_io_init(pmixp_io_engine_t *eng, int fd,
+		pmixp_io_engine_header_t header);
+void pmix_io_finalize(pmixp_io_engine_t *eng, int error);
+
+/* Receiver */
+int pmix_io_first_header(int fd, void *buf, uint32_t *_offs, uint32_t len);
+void pmix_io_rcvd(pmixp_io_engine_t *eng);
+void *pmix_io_rcvd_extract(pmixp_io_engine_t *eng, void *header);
+/* Transmitter */
+void pmix_io_send_enqueue(pmixp_io_engine_t *eng, void *msg);
+void pmix_io_send_progress(pmixp_io_engine_t *eng);
+bool pmix_io_send_pending(pmixp_io_engine_t *eng);
+
+#endif /* PMIXP_IO_H */
diff --git a/src/plugins/mpi/pmix/pmixp_nspaces.c b/src/plugins/mpi/pmix/pmixp_nspaces.c
new file mode 100644
index 0000000..1f3c83f
--- /dev/null
+++ b/src/plugins/mpi/pmix/pmixp_nspaces.c
@@ -0,0 +1,197 @@
+/*****************************************************************************\
+ **  pmix_db.c - PMIx KVS database
+ *****************************************************************************
+ *  Copyright (C) 2014-2015 Artem Polyakov. All rights reserved.
+ *  Copyright (C) 2015      Mellanox Technologies. All rights reserved.
+ *  Written by Artem Polyakov <artpol84@gmail.com, artemp@mellanox.com>.
+ *
+ *  This file is part of SLURM, a resource management program.
+ *  For details, see <http://slurm.schedmd.com/>.
+ *  Please also read the included file: DISCLAIMER.
+ *
+ *  SLURM is free software; you can redistribute it and/or modify it under
+ *  the terms of the GNU General Public License as published by the Free
+ *  Software Foundation; either version 2 of the License, or (at your option)
+ *  any later version.
+ *
+ *  In addition, as a special exception, the copyright holders give permission
+ *  to link the code of portions of this program with the OpenSSL library under
+ *  certain conditions as described in each individual source file, and
+ *  distribute linked combinations including the two. You must obey the GNU
+ *  General Public License in all respects for all of the code used other than
+ *  OpenSSL. If you modify file(s) with this exception, you may extend this
+ *  exception to your version of the file(s), but you are not obligated to do
+ *  so. If you do not wish to do so, delete this exception statement from your
+ *  version.  If you delete this exception statement from all source files in
+ *  the program, then also delete it here.
+ *
+ *  SLURM is distributed in the hope that it will be useful, but WITHOUT ANY
+ *  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+ *  FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
+ *  details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with SLURM; if not, write to the Free Software Foundation, Inc.,
+ *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA.
+ \*****************************************************************************/
+
+#include "pmixp_common.h"
+#include "pmixp_nspaces.h"
+
+pmixp_db_t _pmixp_nspaces;
+
+static void _xfree_nspace(void *n)
+{
+	pmixp_namespace_t *nsptr = n;
+	xfree(nsptr->task_cnts);
+	xfree(nsptr->task_map);
+	xfree(nsptr->task_map_packed);
+	xfree(nsptr);
+}
+
+int pmixp_nspaces_init(void)
+{
+	char *mynspace, *task_map;
+	uint32_t nnodes, ntasks, *task_cnts;
+	int nodeid, rc;
+	hostlist_t hl;
+
+#ifndef NDEBUG
+	_pmixp_nspaces.magic = PMIXP_NSPACE_DB_MAGIC;
+#endif
+	_pmixp_nspaces.nspaces = list_create(_xfree_nspace);
+	mynspace = pmixp_info_namespace();
+	nnodes = pmixp_info_nodes();
+	nodeid = pmixp_info_nodeid();
+	ntasks = pmixp_info_tasks();
+	task_cnts = pmixp_info_tasks_cnts();
+	task_map = pmixp_info_task_map();
+	hl = pmixp_info_step_hostlist();
+	/* Initialize local namespace */
+	rc = pmixp_nspaces_add(mynspace, nnodes, nodeid, ntasks, task_cnts,
+			task_map, hostlist_copy(hl));
+	_pmixp_nspaces.local = pmixp_nspaces_find(mynspace);
+	return rc;
+}
+
+int pmixp_nspaces_finalize(void)
+{
+	list_destroy(_pmixp_nspaces.nspaces);
+	return 0;
+}
+
+int pmixp_nspaces_add(char *name, uint32_t nnodes, int node_id,
+		      uint32_t ntasks, uint32_t *task_cnts,
+		      char *task_map_packed, hostlist_t hl)
+{
+	pmixp_namespace_t *nsptr = xmalloc(sizeof(pmixp_namespace_t));
+	int i;
+
+	xassert(_pmixp_nspaces.magic == PMIXP_NSPACE_DB_MAGIC);
+
+	/* fill up informational part */
+#ifndef NDEBUG
+	nsptr->magic = PMIXP_NSPACE_MAGIC;
+#endif
+	strcpy(nsptr->name, name);
+	nsptr->nnodes = nnodes;
+	nsptr->node_id = node_id;
+	nsptr->ntasks = ntasks;
+	nsptr->task_cnts = xmalloc(sizeof(uint32_t) * nnodes);
+	/* Cannot use memcpy here because of different types */
+	for (i = 0; i < nnodes; i++) {
+		nsptr->task_cnts[i] = task_cnts[i];
+	}
+	nsptr->task_map_packed = xstrdup(task_map_packed);
+	nsptr->task_map = unpack_process_mapping_flat(task_map_packed, nnodes,
+			ntasks, NULL);
+	if (nsptr->task_map == NULL) {
+		xfree(nsptr->task_cnts);
+		xfree(nsptr->task_map_packed);
+		return SLURM_ERROR;
+	}
+	nsptr->hl = hl;
+	list_append(_pmixp_nspaces.nspaces, nsptr);
+	return SLURM_SUCCESS;
+}
+
+pmixp_namespace_t *pmixp_nspaces_local()
+{
+	xassert(_pmixp_nspaces.magic == PMIXP_NSPACE_DB_MAGIC);
+	return _pmixp_nspaces.local;
+}
+
+pmixp_namespace_t *pmixp_nspaces_find(const char *name)
+{
+	xassert(_pmixp_nspaces.magic == PMIXP_NSPACE_DB_MAGIC);
+
+	ListIterator it = list_iterator_create(_pmixp_nspaces.nspaces);
+	pmixp_namespace_t *nsptr = NULL;
+	while (NULL != (nsptr = list_next(it))) {
+		xassert(nsptr->magic == PMIXP_NSPACE_MAGIC);
+		if (0 == strcmp(nsptr->name, name)) {
+			goto exit;
+		}
+	}
+	/* Didn't found one! */
+	nsptr = NULL;
+      exit:
+	return nsptr;
+}
+
+hostlist_t pmixp_nspace_rankhosts(pmixp_namespace_t *nsptr, const int *ranks,
+		size_t nranks)
+{
+	hostlist_t hl = hostlist_create("");
+	int i;
+	for (i = 0; i < nranks; i++) {
+		int rank = ranks[i];
+		int node = nsptr->task_map[rank];
+		char *node_s = hostlist_nth(nsptr->hl, node);
+		hostlist_push(hl, node_s);
+		free(node_s);
+	}
+	hostlist_uniq(hl);
+	return hl;
+}
+
+char *pmixp_nspace_resolve(const char *name, int rank)
+{
+	pmixp_namespace_t *nsptr;
+
+	xassert(_pmixp_nspaces.magic == PMIXP_NSPACE_DB_MAGIC);
+
+	ListIterator it = list_iterator_create(_pmixp_nspaces.nspaces);
+	while (NULL != (nsptr = list_next(it))) {
+		xassert(nsptr->magic == PMIXP_NSPACE_MAGIC);
+		if (0 == strcmp(nsptr->name, name)) {
+			break;
+		}
+	}
+
+	if (NULL == nsptr) {
+		return NULL;
+	}
+	xassert(rank < nsptr->ntasks);
+
+	return hostlist_nth(nsptr->hl, nsptr->task_map[rank]);
+}
+
+size_t pmixp_nspace_mdx_lsize(List l)
+{
+	ListIterator it = list_iterator_create(l);
+	pmix_modex_data_t *data;
+	size_t ret = 0;
+
+	while (NULL != (data = list_next(it))) {
+		/* we need to save:
+		 * - rank (uint32_t)
+		 * - scope (uint32_t)
+		 * - size of the blob (uint32_t)
+		 * - blob data (data->size)
+		 */
+		ret += data->size + 3 * sizeof(int);
+	}
+	list_iterator_destroy(it);
+	return ret;
+}
diff --git a/src/plugins/mpi/pmix/pmixp_nspaces.h b/src/plugins/mpi/pmix/pmixp_nspaces.h
new file mode 100644
index 0000000..5b380f6
--- /dev/null
+++ b/src/plugins/mpi/pmix/pmixp_nspaces.h
@@ -0,0 +1,102 @@
+/*****************************************************************************\
+ **  pmix_db.h - PMIx KVS database
+ *****************************************************************************
+ *  Copyright (C) 2014-2015 Artem Polyakov. All rights reserved.
+ *  Copyright (C) 2015      Mellanox Technologies. All rights reserved.
+ *  Written by Artem Polyakov <artpol84@gmail.com, artemp@mellanox.com>.
+ *
+ *  This file is part of SLURM, a resource management program.
+ *  For details, see <http://slurm.schedmd.com/>.
+ *  Please also read the included file: DISCLAIMER.
+ *
+ *  SLURM is free software; you can redistribute it and/or modify it under
+ *  the terms of the GNU General Public License as published by the Free
+ *  Software Foundation; either version 2 of the License, or (at your option)
+ *  any later version.
+ *
+ *  In addition, as a special exception, the copyright holders give permission
+ *  to link the code of portions of this program with the OpenSSL library under
+ *  certain conditions as described in each individual source file, and
+ *  distribute linked combinations including the two. You must obey the GNU
+ *  General Public License in all respects for all of the code used other than
+ *  OpenSSL. If you modify file(s) with this exception, you may extend this
+ *  exception to your version of the file(s), but you are not obligated to do
+ *  so. If you do not wish to do so, delete this exception statement from your
+ *  version.  If you delete this exception statement from all source files in
+ *  the program, then also delete it here.
+ *
+ *  SLURM is distributed in the hope that it will be useful, but WITHOUT ANY
+ *  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+ *  FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
+ *  details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with SLURM; if not, write to the Free Software Foundation, Inc.,
+ *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA.
+ \*****************************************************************************/
+
+#ifndef PMIXP_NSPACES_H
+#define PMIXP_NSPACES_H
+
+#include "pmixp_common.h"
+#include "pmixp_info.h"
+#include "pmixp_debug.h"
+#include "pmixp_state.h"
+
+typedef struct {
+	void *blob;
+	int blob_sz;
+} pmixp_blob_t;
+
+typedef struct {
+	pmix_modex_data_t data;
+	pmix_scope_t scope;
+} pmixp_modex_t;
+
+typedef struct {
+#ifndef NDEBUG
+#define PMIXP_NSPACE_MAGIC 0xCAFED00D
+	int magic;
+#endif
+	char name[PMIX_MAX_NSLEN];
+	uint32_t nnodes; /* number of nodes in this namespace              */
+	int node_id; /* relative position of this node in this step    */
+	uint32_t ntasks; /* total number of tasks in this namespace        */
+	uint32_t *task_cnts; /* Number of tasks on each node in this namespace */
+	char *task_map_packed; /* string represents packed task mapping information */
+	uint32_t *task_map; /* i'th task is located on task_map[i] node     */
+	hostlist_t hl;
+} pmixp_namespace_t;
+
+typedef struct {
+#ifndef NDEBUG
+#define PMIXP_NSPACE_DB_MAGIC 0xCAFEBABE
+	int magic;
+#endif
+	List nspaces;
+	pmixp_namespace_t *local;
+} pmixp_db_t;
+
+int pmixp_nspaces_init(void);
+int pmixp_nspaces_finalize(void);
+pmixp_namespace_t *pmixp_nspaces_find(const char *name);
+pmixp_namespace_t *pmixp_nspaces_local(void);
+int pmixp_nspaces_add(char *name, uint32_t nnodes, int node_id,
+		      uint32_t ntasks, uint32_t *task_cnts,
+		      char *task_map_packed, hostlist_t hl);
+
+/* operations on the specific namespace */
+static inline hostlist_t pmixp_nspace_hostlist(pmixp_namespace_t *nsptr)
+{
+	hostlist_t hl = hostlist_copy(nsptr->hl);
+	return hl;
+}
+
+hostlist_t pmixp_nspace_rankhosts(pmixp_namespace_t *nsptr,
+				  const int *ranks, size_t nranks);
+char *pmixp_nspace_resolve(const char *name, int rank);
+
+size_t pmixp_nspace_mdx_lsize(List l);
+int pmixp_nspaces_push(Buf buf, int cnt);
+
+#endif /* PMIXP_NSPACES_H */
diff --git a/src/plugins/mpi/pmix/pmixp_server.c b/src/plugins/mpi/pmix/pmixp_server.c
new file mode 100644
index 0000000..3b91fec
--- /dev/null
+++ b/src/plugins/mpi/pmix/pmixp_server.c
@@ -0,0 +1,417 @@
+/*****************************************************************************\
+ **  pmix_server.c - PMIx server side functionality
+ *****************************************************************************
+ *  Copyright (C) 2014-2015 Artem Polyakov. All rights reserved.
+ *  Copyright (C) 2015      Mellanox Technologies. All rights reserved.
+ *  Written by Artem Polyakov <artpol84@gmail.com, artemp@mellanox.com>.
+ *
+ *  This file is part of SLURM, a resource management program.
+ *  For details, see <http://slurm.schedmd.com/>.
+ *  Please also read the included file: DISCLAIMER.
+ *
+ *  SLURM is free software; you can redistribute it and/or modify it under
+ *  the terms of the GNU General Public License as published by the Free
+ *  Software Foundation; either version 2 of the License, or (at your option)
+ *  any later version.
+ *
+ *  In addition, as a special exception, the copyright holders give permission
+ *  to link the code of portions of this program with the OpenSSL library under
+ *  certain conditions as described in each individual source file, and
+ *  distribute linked combinations including the two. You must obey the GNU
+ *  General Public License in all respects for all of the code used other than
+ *  OpenSSL. If you modify file(s) with this exception, you may extend this
+ *  exception to your version of the file(s), but you are not obligated to do
+ *  so. If you do not wish to do so, delete this exception statement from your
+ *  version.  If you delete this exception statement from all source files in
+ *  the program, then also delete it here.
+ *
+ *  SLURM is distributed in the hope that it will be useful, but WITHOUT ANY
+ *  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+ *  FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
+ *  details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with SLURM; if not, write to the Free Software Foundation, Inc.,
+ *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA.
+ \*****************************************************************************/
+
+#include "pmixp_common.h"
+#include "pmixp_info.h"
+#include "pmixp_coll.h"
+#include "pmixp_debug.h"
+#include "pmixp_io.h"
+#include "pmixp_client.h"
+#include "pmixp_server.h"
+#include "pmixp_nspaces.h"
+#include "pmixp_state.h"
+#include "pmixp_client.h"
+#include "pmixp_dmdx.h"
+
+#include <pmix_server.h>
+
+#define PMIX_SERVER_MSG_MAGIC 0xCAFECA11
+typedef struct {
+	uint32_t magic;
+	uint32_t type;
+	uint32_t seq;
+	uint32_t nodeid;
+	uint32_t msgsize;
+} send_header_t;
+
+#define SEND_HDR_SIZE (5 * sizeof(uint32_t))
+
+typedef struct {
+	uint32_t size;		/* Has to be first (appended by SLURM API) */
+	send_header_t send_hdr;
+} recv_header_t;
+#define RCVD_HDR_SIZE (sizeof(uint32_t) + SEND_HDR_SIZE)
+
+Buf pmixp_server_new_buf(void)
+{
+	Buf buf = create_buf(xmalloc(SEND_HDR_SIZE), SEND_HDR_SIZE);
+	/* Skip header. It will be filled right before the sending */
+	set_buf_offset(buf, SEND_HDR_SIZE);
+	return buf;
+}
+
+static uint32_t _recv_payload_size(void *buf);
+static int _send_pack_hdr(void *host, void *net);
+static int _recv_unpack_hdr(void *net, void *host);
+
+static bool _serv_readable(eio_obj_t *obj);
+static int _serv_read(eio_obj_t *obj, List objs);
+static void _process_server_request(recv_header_t *_hdr, void *payload);
+
+static struct io_operations peer_ops = {
+	.readable = _serv_readable,
+	.handle_read = _serv_read
+};
+
+pmixp_io_engine_header_t srv_rcvd_header = {
+	.host_size = sizeof(recv_header_t),
+	.net_size = RCVD_HDR_SIZE,
+	.pack_hdr_cb = NULL,
+	.unpack_hdr_cb = _recv_unpack_hdr,
+	.pay_size_cb = _recv_payload_size
+};
+
+static volatile int _was_initialized = 0;
+
+int pmixp_stepd_init(const stepd_step_rec_t *job, char ***env)
+{
+	char *path;
+	int fd, rc;
+
+	if (SLURM_SUCCESS != (rc = pmixp_info_set(job, env))) {
+		PMIXP_ERROR("pmixp_info_set(job, env) failed");
+		return rc;
+	}
+
+	/* Create UNIX socket for slurmd communication */
+	path = pmixp_info_nspace_usock(pmixp_info_namespace());
+	if (NULL == path) {
+		PMIXP_ERROR("Out-of-memory");
+		rc = SLURM_ERROR;
+		goto err_path;
+	}
+	if ((fd = pmixp_usock_create_srv(path)) < 0) {
+		rc = SLURM_ERROR;
+		goto err_usock;
+	}
+	fd_set_close_on_exec(fd);
+	pmixp_info_srv_contacts(path, fd);
+
+	if (SLURM_SUCCESS != (rc = pmixp_nspaces_init())) {
+		PMIXP_ERROR("pmixp_nspaces_init() failed");
+		goto err_usock;
+	}
+
+	if (SLURM_SUCCESS != (rc = pmixp_state_init())) {
+		PMIXP_ERROR("pmixp_state_init() failed");
+		goto err_state;
+	}
+
+	if (SLURM_SUCCESS != (rc = pmixp_dmdx_init())) {
+		PMIXP_ERROR("pmixp_dmdx_init() failed");
+		goto err_dmdx;
+	}
+
+	if (SLURM_SUCCESS != (rc = pmixp_libpmix_init())) {
+		PMIXP_ERROR("pmixp_libpmix_init() failed");
+		goto err_lib;
+	}
+
+	if (SLURM_SUCCESS != (rc = pmixp_libpmix_job_set())) {
+		PMIXP_ERROR("pmixp_libpmix_job_set() failed");
+		goto err_job;
+	}
+
+	xfree(path);
+	_was_initialized = 1;
+	return SLURM_SUCCESS;
+
+      err_job:
+	pmixp_libpmix_finalize();
+      err_lib:
+	pmixp_dmdx_finalize();
+      err_dmdx:
+	pmixp_state_finalize();
+      err_state:
+	pmixp_nspaces_finalize();
+	err_usock:
+	xfree(path);
+      err_path:
+	pmixp_info_free();
+	return rc;
+}
+
+int pmixp_stepd_finalize(void)
+{
+	char *path;
+	if (!_was_initialized) {
+		/* nothing to do */
+		return 0;
+	}
+
+	pmixp_libpmix_finalize();
+	pmixp_dmdx_finalize();
+	pmixp_state_finalize();
+	pmixp_nspaces_finalize();
+
+	/* cleanup the usock */
+	PMIXP_DEBUG("Remove PMIx plugin usock");
+	close(pmixp_info_srv_fd());
+	path = pmixp_info_nspace_usock(pmixp_info_namespace());
+	unlink(path);
+	xfree(path);
+
+	/* free the information */
+	pmixp_info_free();
+	return SLURM_SUCCESS;
+}
+
+/*
+ * TODO: we need to keep track of the "me"
+ * structures created here, because we need to
+ * free them in "pmixp_stepd_finalize"
+ */
+void pmix_server_new_conn(int fd)
+{
+	eio_obj_t *obj;
+	PMIXP_DEBUG("Request from fd = %d", fd);
+
+	/* Set nonblocking */
+	fd_set_nonblocking(fd);
+	fd_set_close_on_exec(fd);
+
+	pmixp_io_engine_t *me = xmalloc(sizeof(pmixp_io_engine_t));
+	pmix_io_init(me, fd, srv_rcvd_header);
+	/* We use slurm_forward_data to send message to stepd's
+	 * SLURM will put user ID there. We need to skip it.
+	 */
+	pmix_io_rcvd_padding(me, sizeof(uint32_t));
+
+	/* TODO: in future try to process the request right here
+	 * use eio only in case of blocking operation
+	 * NOW: always defer to debug the blocking case
+	 */
+	obj = eio_obj_create(fd, &peer_ops, (void *)me);
+	eio_new_obj(pmixp_info_io(), obj);
+}
+
+/*
+ *  Server message processing
+ */
+
+static uint32_t _recv_payload_size(void *buf)
+{
+	recv_header_t *ptr = (recv_header_t *)buf;
+	send_header_t *hdr = &ptr->send_hdr;
+	xassert(ptr->size == hdr->msgsize + SEND_HDR_SIZE);
+	xassert(hdr->magic == PMIX_SERVER_MSG_MAGIC);
+	return hdr->msgsize;
+}
+
+/*
+ * Pack message header.
+ * Returns packed size
+ * Note: asymmetric to _recv_unpack_hdr because of additional SLURM header
+ */
+static int _send_pack_hdr(void *host, void *net)
+{
+	send_header_t *ptr = (send_header_t *)host;
+	Buf packbuf = create_buf(net, sizeof(send_header_t));
+	int size = 0;
+	pack32(ptr->magic, packbuf);
+	pack32(ptr->type, packbuf);
+	pack32(ptr->seq, packbuf);
+	pack32(ptr->nodeid, packbuf);
+	pack32(ptr->msgsize, packbuf);
+	size = get_buf_offset(packbuf);
+	xassert(size == SEND_HDR_SIZE);
+	/* free the Buf packbuf, but not the memory to which it points */
+	packbuf->head = NULL;
+	free_buf(packbuf);
+	return size;
+}
+
+/*
+ * Unpack message header.
+ * Returns 0 on success and -errno on failure
+ * Note: asymmetric to _send_pack_hdr because of additional SLURM header
+ */
+static int _recv_unpack_hdr(void *net, void *host)
+{
+	recv_header_t *ptr = (recv_header_t *)host;
+	Buf packbuf = create_buf(net, sizeof(recv_header_t));
+	if (unpack32(&ptr->size, packbuf)) {
+		return -EINVAL;
+	}
+	if (unpack32(&ptr->send_hdr.magic, packbuf)) {
+		return -EINVAL;
+	}
+	xassert(ptr->send_hdr.magic == PMIX_SERVER_MSG_MAGIC);
+
+	if (unpack32(&ptr->send_hdr.type, packbuf)) {
+		return -EINVAL;
+	}
+
+	if (unpack32(&ptr->send_hdr.seq, packbuf)) {
+		return -EINVAL;
+	}
+
+	if (unpack32(&ptr->send_hdr.nodeid, packbuf)) {
+		return -EINVAL;
+	}
+
+	if (unpack32(&ptr->send_hdr.msgsize, packbuf)) {
+		return -EINVAL;
+	}
+	/* free the Buf packbuf, but not the memory to which it points */
+	packbuf->head = NULL;
+	free_buf(packbuf);
+	return 0;
+}
+
+int pmixp_server_send(char *hostlist, pmixp_srv_cmd_t type, uint32_t seq,
+		const char *addr, void *data, size_t size)
+{
+	send_header_t hdr;
+	char nhdr[sizeof(send_header_t)];
+	size_t hsize;
+	int rc;
+
+	hdr.magic = PMIX_SERVER_MSG_MAGIC;
+	hdr.type = type;
+	hdr.msgsize = size - SEND_HDR_SIZE;
+	hdr.seq = seq;
+	/* Store global nodeid that is
+	 *  independent from exact collective */
+	hdr.nodeid = pmixp_info_nodeid_job();
+	hsize = _send_pack_hdr(&hdr, nhdr);
+	memcpy(data, nhdr, hsize);
+
+	rc = pmixp_stepd_send(hostlist, addr, data, size);
+	if (SLURM_SUCCESS != rc) {
+		PMIXP_ERROR(
+				"Cannot send message to %s, size = %u, hostlist:\n%s",
+				addr, (uint32_t) size, hostlist);
+	}
+	return rc;
+}
+
+static bool _serv_readable(eio_obj_t *obj)
+{
+	/* We should delete connection right when it  was closed or failed */
+	xassert(obj->shutdown == false);
+	return true;
+}
+
+static void _process_server_request(recv_header_t *_hdr, void *payload)
+{
+	send_header_t *hdr = &_hdr->send_hdr;
+	char *nodename = pmixp_info_job_host(hdr->nodeid);
+	Buf buf;
+	int rc;
+
+	buf = create_buf(payload, hdr->msgsize);
+
+	switch (hdr->type) {
+	case PMIXP_MSG_FAN_IN:
+	case PMIXP_MSG_FAN_OUT: {
+		pmixp_coll_t *coll;
+		pmix_proc_t *procs = NULL;
+		size_t nprocs = 0;
+		pmixp_coll_type_t type = 0;
+
+		rc = pmixp_coll_unpack_ranges(buf, &type, &procs, &nprocs);
+		if (SLURM_SUCCESS != rc) {
+			PMIXP_ERROR("Bad message header from node %s", nodename);
+			return;
+		}
+		coll = pmixp_state_coll_get(type, procs, nprocs);
+		xfree(procs);
+
+		PMIXP_DEBUG(
+				"FENCE collective message from node \"%s\", type = %s",
+				nodename,
+				(PMIXP_MSG_FAN_IN == hdr->type) ?
+						"fan-in" : "fan-out");
+
+		if (SLURM_SUCCESS
+				!= pmixp_coll_check_seq(coll, hdr->seq,
+						nodename)) {
+			/* stop processing discardig this message */
+			break;
+		}
+
+		if (PMIXP_MSG_FAN_IN == hdr->type) {
+			pmixp_coll_contrib_node(coll, nodename, buf);
+			/* we don't need this buffer anymore */
+			free_buf(buf);
+		} else {
+			pmixp_coll_bcast(coll, buf);
+			/* buf will be free'd by the PMIx callback */
+		}
+
+		break;
+	}
+	case PMIXP_MSG_DMDX: {
+		pmixp_dmdx_process(buf, nodename, hdr->seq);
+		break;
+	}
+	default:
+		PMIXP_ERROR("Unknown message type %d", hdr->type);
+		break;
+	}
+	xfree(nodename);
+}
+
+static int _serv_read(eio_obj_t *obj, List objs)
+{
+
+	PMIXP_DEBUG("fd = %d", obj->fd);
+	pmixp_io_engine_t *me = (pmixp_io_engine_t *)obj->arg;
+
+	pmixp_debug_hang(0);
+
+	/* Read and process all received messages */
+	while (1) {
+		pmix_io_rcvd(me);
+		if (pmix_io_finalized(me)) {
+			obj->shutdown = true;
+			PMIXP_DEBUG("Connection finalized fd = %d", obj->fd);
+			eio_remove_obj(obj, objs);
+			return 0;
+		}
+		if (pmix_io_rcvd_ready(me)) {
+			recv_header_t hdr;
+			void *msg = pmix_io_rcvd_extract(me, &hdr);
+			_process_server_request(&hdr, msg);
+		} else {
+			/* No more complete messages */
+			break;
+		}
+	}
+	return 0;
+}
diff --git a/src/plugins/mpi/pmix/pmixp_server.h b/src/plugins/mpi/pmix/pmixp_server.h
new file mode 100644
index 0000000..d68566c
--- /dev/null
+++ b/src/plugins/mpi/pmix/pmixp_server.h
@@ -0,0 +1,58 @@
+/*****************************************************************************\
+ **  pmix_server.h - PMIx server side functionality
+ *****************************************************************************
+ *  Copyright (C) 2014-2015 Artem Polyakov. All rights reserved.
+ *  Copyright (C) 2015      Mellanox Technologies. All rights reserved.
+ *  Written by Artem Polyakov <artpol84@gmail.com, artemp@mellanox.com>.
+ *
+ *  This file is part of SLURM, a resource management program.
+ *  For details, see <http://slurm.schedmd.com/>.
+ *  Please also read the included file: DISCLAIMER.
+ *
+ *  SLURM is free software; you can redistribute it and/or modify it under
+ *  the terms of the GNU General Public License as published by the Free
+ *  Software Foundation; either version 2 of the License, or (at your option)
+ *  any later version.
+ *
+ *  In addition, as a special exception, the copyright holders give permission
+ *  to link the code of portions of this program with the OpenSSL library under
+ *  certain conditions as described in each individual source file, and
+ *  distribute linked combinations including the two. You must obey the GNU
+ *  General Public License in all respects for all of the code used other than
+ *  OpenSSL. If you modify file(s) with this exception, you may extend this
+ *  exception to your version of the file(s), but you are not obligated to do
+ *  so. If you do not wish to do so, delete this exception statement from your
+ *  version.  If you delete this exception statement from all source files in
+ *  the program, then also delete it here.
+ *
+ *  SLURM is distributed in the hope that it will be useful, but WITHOUT ANY
+ *  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+ *  FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
+ *  details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with SLURM; if not, write to the Free Software Foundation, Inc.,
+ *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA.
+ \*****************************************************************************/
+
+#ifndef PMIXP_SERVER_H
+#define PMIXP_SERVER_H
+
+#include "pmixp_common.h"
+
+typedef enum {
+	PMIXP_MSG_FAN_IN,
+	PMIXP_MSG_FAN_OUT,
+	PMIXP_MSG_DMDX
+} pmixp_srv_cmd_t;
+
+int pmixp_stepd_init(const stepd_step_rec_t *job, char ***env);
+int pmixp_stepd_finalize(void);
+int pmix_srun_init(const mpi_plugin_client_info_t *job, char ***env);
+void pmix_server_new_conn(int fd);
+int pmixp_server_send(char *hostlist, pmixp_srv_cmd_t type, uint32_t seq,
+		const char *addr, void *data, size_t size);
+
+Buf pmixp_server_new_buf(void);
+
+#endif /* PMIXP_SERVER_H */
diff --git a/src/plugins/mpi/pmix/pmixp_state.c b/src/plugins/mpi/pmix/pmixp_state.c
new file mode 100644
index 0000000..b9f7a70
--- /dev/null
+++ b/src/plugins/mpi/pmix/pmixp_state.c
@@ -0,0 +1,182 @@
+/*****************************************************************************\
+ **  pmix_state.c - PMIx agent state related code
+ *****************************************************************************
+ *  Copyright (C) 2014-2015 Artem Polyakov. All rights reserved.
+ *  Copyright (C) 2015      Mellanox Technologies. All rights reserved.
+ *  Written by Artem Polyakov <artpol84@gmail.com, artemp@mellanox.com>.
+ *
+ *  This file is part of SLURM, a resource management program.
+ *  For details, see <http://slurm.schedmd.com/>.
+ *  Please also read the included file: DISCLAIMER.
+ *
+ *  SLURM is free software; you can redistribute it and/or modify it under
+ *  the terms of the GNU General Public License as published by the Free
+ *  Software Foundation; either version 2 of the License, or (at your option)
+ *  any later version.
+ *
+ *  In addition, as a special exception, the copyright holders give permission
+ *  to link the code of portions of this program with the OpenSSL library under
+ *  certain conditions as described in each individual source file, and
+ *  distribute linked combinations including the two. You must obey the GNU
+ *  General Public License in all respects for all of the code used other than
+ *  OpenSSL. If you modify file(s) with this exception, you may extend this
+ *  exception to your version of the file(s), but you are not obligated to do
+ *  so. If you do not wish to do so, delete this exception statement from your
+ *  version.  If you delete this exception statement from all source files in
+ *  the program, then also delete it here.
+ *
+ *  SLURM is distributed in the hope that it will be useful, but WITHOUT ANY
+ *  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+ *  FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
+ *  details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with SLURM; if not, write to the Free Software Foundation, Inc.,
+ *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA.
+ \*****************************************************************************/
+
+#include "pmixp_common.h"
+#include "pmixp_debug.h"
+#include "pmixp_info.h"
+#include "pmixp_state.h"
+#include "pmixp_nspaces.h"
+#include "pmixp_coll.h"
+
+pmixp_state_t _pmixp_state;
+
+void _xfree_coll(void *x)
+{
+	pmixp_coll_t *coll = (pmixp_coll_t *)x;
+	pmixp_coll_free(coll);
+	xfree(coll);
+}
+
+int pmixp_state_init(void)
+{
+#ifndef NDEBUG
+	_pmixp_state.magic = PMIX_STATE_MAGIC;
+#endif
+	_pmixp_state.coll = list_create(_xfree_coll);
+
+	pthread_mutexattr_t attr;
+	pthread_mutexattr_init(&attr);
+	pthread_mutex_init(&_pmixp_state.lock, &attr);
+	pthread_mutexattr_destroy(&attr);
+	return SLURM_SUCCESS;
+}
+
+void pmixp_state_finalize(void)
+{
+#ifndef NDEBUG
+	_pmixp_state.magic = 0;
+#endif
+	list_destroy(_pmixp_state.coll);
+}
+
+static bool _compare_ranges(const pmix_proc_t *r1, const pmix_proc_t *r2,
+		size_t nprocs)
+{
+	int i;
+	for (i = 0; i < nprocs; i++) {
+		if (0 != strcmp(r1[i].nspace, r2[i].nspace)) {
+			return false;
+		}
+		if (r1[i].rank != r2[i].rank) {
+			return false;
+		}
+	}
+	return true;
+}
+
+static pmixp_coll_t *_find_collective(pmixp_coll_type_t type,
+				      const pmix_proc_t *procs,
+				      size_t nprocs)
+{
+	pmixp_coll_t *coll = NULL, *ret = NULL;
+	ListIterator it;
+
+	/* Walk through the list looking for the collective descriptor */
+	it = list_iterator_create(_pmixp_state.coll);
+	while (NULL != (coll = list_next(it))) {
+		if (coll->nprocs != nprocs) {
+			continue;
+		}
+		if (coll->type != type) {
+			continue;
+		}
+		if (0 == coll->nprocs) {
+			ret = coll;
+			goto exit;
+		}
+		if (_compare_ranges(coll->procs, procs, nprocs)) {
+			ret = coll;
+			goto exit;
+		}
+	}
+      exit:
+	list_iterator_destroy(it);
+	return ret;
+}
+
+pmixp_coll_t *pmixp_state_coll_get(pmixp_coll_type_t type,
+				   const pmix_proc_t *procs,
+				   size_t nprocs)
+{
+	pmixp_coll_t *ret = NULL;
+
+	/* Collectives are created once for each type and process set
+	 * and resides till the end of jobstep lifetime.
+	 * So in most cases we will find that collective is already
+	 * exists.
+	 * First we try to find collective in the list without locking. */
+
+	if (NULL != (ret = _find_collective(type, procs, nprocs))) {
+		return ret;
+	}
+
+	/* if we failed to find the collective we most probably need
+	 * to create a new structure. To do so we need to lo lock the
+	 * whole state and try to search again to exclude situation where
+	 * concurent thread already created it while we were doing the
+	 * first search */
+
+	if (0 != pmixp_coll_belong_chk(type, procs, nprocs)) {
+		return NULL;
+	}
+
+	pthread_mutex_lock(&_pmixp_state.lock);
+
+	if (NULL == (ret = _find_collective(type, procs, nprocs))) {
+		/* 1. Create and insert unitialized but locked coll
+		 * structure into the list. We can release the state
+		 * structure right after that */
+		ret = xmalloc(sizeof(*ret));
+		/* initialize with unlocked list but locked element */
+		if (PMIX_SUCCESS != pmixp_coll_init(ret, procs, nprocs, type)) {
+			if (NULL != ret->procs) {
+				xfree(ret->procs);
+			}
+			xfree(ret);
+			ret = NULL;
+		} else {
+			list_append(_pmixp_state.coll, ret);
+		}
+	}
+
+	pthread_mutex_unlock(&_pmixp_state.lock);
+	return ret;
+}
+
+void pmixp_state_coll_cleanup(void)
+{
+	pmixp_coll_t *coll = NULL;
+	ListIterator it;
+	time_t ts = time(NULL);
+
+	/* Walk through the list looking for the collective descriptor */
+	it = list_iterator_create(_pmixp_state.coll);
+	while (NULL != (coll = list_next(it))) {
+		pmixp_coll_reset_if_to(coll, ts);
+	}
+	list_iterator_destroy(it);
+}
diff --git a/src/plugins/mpi/pmix/pmixp_state.h b/src/plugins/mpi/pmix/pmixp_state.h
new file mode 100644
index 0000000..74821be
--- /dev/null
+++ b/src/plugins/mpi/pmix/pmixp_state.h
@@ -0,0 +1,86 @@
+/*****************************************************************************\
+ **  pmix_state.h - PMIx agent state related code
+ *****************************************************************************
+ *  Copyright (C) 2014-2015 Artem Polyakov. All rights reserved.
+ *  Copyright (C) 2015      Mellanox Technologies. All rights reserved.
+ *  Written by Artem Polyakov <artpol84@gmail.com, artemp@mellanox.com>.
+ *
+ *  This file is part of SLURM, a resource management program.
+ *  For details, see <http://slurm.schedmd.com/>.
+ *  Please also read the included file: DISCLAIMER.
+ *
+ *  SLURM is free software; you can redistribute it and/or modify it under
+ *  the terms of the GNU General Public License as published by the Free
+ *  Software Foundation; either version 2 of the License, or (at your option)
+ *  any later version.
+ *
+ *  In addition, as a special exception, the copyright holders give permission
+ *  to link the code of portions of this program with the OpenSSL library under
+ *  certain conditions as described in each individual source file, and
+ *  distribute linked combinations including the two. You must obey the GNU
+ *  General Public License in all respects for all of the code used other than
+ *  OpenSSL. If you modify file(s) with this exception, you may extend this
+ *  exception to your version of the file(s), but you are not obligated to do
+ *  so. If you do not wish to do so, delete this exception statement from your
+ *  version.  If you delete this exception statement from all source files in
+ *  the program, then also delete it here.
+ *
+ *  SLURM is distributed in the hope that it will be useful, but WITHOUT ANY
+ *  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+ *  FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
+ *  details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with SLURM; if not, write to the Free Software Foundation, Inc.,
+ *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA.
+ \*****************************************************************************/
+
+#ifndef PMIXP_STATE_H
+#define PMIXP_STATE_H
+
+#include "pmixp_common.h"
+#include "pmixp_debug.h"
+#include "pmixp_io.h"
+#include "pmixp_coll.h"
+#include "pmixp_dmdx.h"
+
+/*
+ * PMIx plugin state structure
+ */
+
+typedef struct {
+#ifndef NDEBUG
+#define PMIX_STATE_MAGIC 0xFEEDCAFE
+	int magic;
+#endif
+	List coll;
+	eio_handle_t *srv_handle;
+	pthread_mutex_t lock;
+} pmixp_state_t;
+
+extern pmixp_state_t _pmixp_state;
+
+/*
+ * General PMIx plugin state manipulation functions
+ */
+
+int pmixp_state_init(void);
+void pmixp_state_finalize(void);
+
+static inline void pmixp_state_sanity_check(void)
+{
+	xassert(_pmixp_state.magic == PMIX_STATE_MAGIC);
+}
+
+/*
+ * Collective state
+ */
+
+pmixp_coll_t *pmixp_state_coll_get(pmixp_coll_type_t type,
+		const pmix_proc_t *ranges, size_t nranges);
+pmixp_coll_t *pmixp_state_coll_new(pmixp_coll_type_t type,
+		const pmix_proc_t *ranges, size_t nranges);
+
+void pmixp_state_coll_cleanup(void);
+
+#endif /* PMIXP_STATE_H */
diff --git a/src/plugins/mpi/pmix/pmixp_utils.c b/src/plugins/mpi/pmix/pmixp_utils.c
new file mode 100644
index 0000000..76673d1
--- /dev/null
+++ b/src/plugins/mpi/pmix/pmixp_utils.c
@@ -0,0 +1,366 @@
+/*****************************************************************************\
+ **	pmix_utils.c - Various PMIx utility functions
+ *****************************************************************************
+ *  Copyright (C) 2014-2015 Artem Polyakov. All rights reserved.
+ *  Copyright (C) 2015      Mellanox Technologies. All rights reserved.
+ *  Written by Artem Polyakov <artpol84@gmail.com, artemp@mellanox.com>.
+ *
+ *  This file is part of SLURM, a resource management program.
+ *  For details, see <http://slurm.schedmd.com/>.
+ *  Please also read the included file: DISCLAIMER.
+ *
+ *  SLURM is free software; you can redistribute it and/or modify it under
+ *  the terms of the GNU General Public License as published by the Free
+ *  Software Foundation; either version 2 of the License, or (at your option)
+ *  any later version.
+ *
+ *  In addition, as a special exception, the copyright holders give permission
+ *  to link the code of portions of this program with the OpenSSL library under
+ *  certain conditions as described in each individual source file, and
+ *  distribute linked combinations including the two. You must obey the GNU
+ *  General Public License in all respects for all of the code used other than
+ *  OpenSSL. If you modify file(s) with this exception, you may extend this
+ *  exception to your version of the file(s), but you are not obligated to do
+ *  so. If you do not wish to do so, delete this exception statement from your
+ *  version.  If you delete this exception statement from all source files in
+ *  the program, then also delete it here.
+ *
+ *  SLURM is distributed in the hope that it will be useful, but WITHOUT ANY
+ *  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+ *  FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
+ *  details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with SLURM; if not, write to the Free Software Foundation, Inc.,
+ *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA.
+ \*****************************************************************************/
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <sys/un.h>
+#include <errno.h>
+#include <poll.h>
+#include <time.h>
+#include <sys/stat.h>
+#include <unistd.h>
+#include <dirent.h>
+
+#include "pmixp_common.h"
+#include "pmixp_utils.h"
+#include "pmixp_debug.h"
+
+#define PMIXP_MAX_RETRY 7
+
+void pmixp_xfree_xmalloced(void *x)
+{
+	xfree(x);
+}
+
+void pmixp_free_Buf(void *x)
+{
+	Buf buf = (Buf)x;
+	free_buf(buf);
+}
+
+int pmixp_usock_create_srv(char *path)
+{
+	static struct sockaddr_un sa;
+	int ret = 0;
+
+	if (strlen(path) >= sizeof(sa.sun_path)) {
+		PMIXP_ERROR_STD("UNIX socket path is too long: %lu, max %lu",
+				(unsigned long) strlen(path),
+				(unsigned long) sizeof(sa.sun_path) - 1);
+		return SLURM_ERROR;
+	}
+
+	int fd = socket(AF_UNIX, SOCK_STREAM, 0);
+	if (fd < 0) {
+		PMIXP_ERROR_STD("Cannot create UNIX socket");
+		return SLURM_ERROR;
+	}
+
+	memset(&sa, 0, sizeof(sa));
+	sa.sun_family = AF_UNIX;
+	strcpy(sa.sun_path, path);
+	if (ret = bind(fd, (struct sockaddr *)&sa, SUN_LEN(&sa))) {
+		PMIXP_ERROR_STD("Cannot bind() UNIX socket %s", path);
+		goto err_fd;
+	}
+
+	if ((ret = listen(fd, 64))) {
+		PMIXP_ERROR_STD("Cannot listen(%d, 64) UNIX socket %s", fd,
+				path);
+		goto err_bind;
+
+	}
+	return fd;
+
+      err_bind:
+	unlink(path);
+      err_fd:
+	close(fd);
+	return ret;
+}
+
+size_t pmixp_read_buf(int sd, void *buf, size_t count, int *shutdown,
+		bool blocking)
+{
+	ssize_t ret, offs = 0;
+
+	*shutdown = 0;
+
+	if (!blocking && !pmixp_fd_read_ready(sd, shutdown)) {
+		return 0;
+	}
+
+	if (blocking) {
+		fd_set_blocking(sd);
+	}
+
+	while (count - offs > 0) {
+		ret = read(sd, (char *)buf + offs, count - offs);
+		if (ret > 0) {
+			offs += ret;
+			continue;
+		} else if (ret == 0) {
+			/* connection closed. */
+			*shutdown = 1;
+			return offs;
+		}
+		switch (errno) {
+		case EINTR:
+			continue;
+		case EWOULDBLOCK:
+			/* we can get here in non-blocking mode only */
+			return offs;
+		default:
+			PMIXP_ERROR_STD("blocking=%d", blocking);
+			*shutdown = -errno;
+			return offs;
+		}
+	}
+
+	if (blocking) {
+		fd_set_nonblocking(sd);
+	}
+	return offs;
+}
+
+size_t pmixp_write_buf(int sd, void *buf, size_t count, int *shutdown,
+		bool blocking)
+{
+	ssize_t ret, offs = 0;
+
+	*shutdown = 0;
+
+	if (!blocking && !pmixp_fd_write_ready(sd, shutdown)) {
+		return 0;
+	}
+
+	if (blocking) {
+		fd_set_blocking(sd);
+	}
+
+	while (count - offs > 0) {
+		ret = write(sd, (char *)buf + offs, count - offs);
+		if (ret > 0) {
+			offs += ret;
+			continue;
+		}
+		switch (errno) {
+		case EINTR:
+			continue;
+		case EWOULDBLOCK:
+			return offs;
+		default:
+			*shutdown = -errno;
+			return offs;
+		}
+	}
+
+	if (blocking) {
+		fd_set_nonblocking(sd);
+	}
+
+	return offs;
+}
+
+bool pmixp_fd_read_ready(int fd, int *shutdown)
+{
+	struct pollfd pfd[1];
+	int rc;
+	pfd[0].fd = fd;
+	pfd[0].events = POLLIN;
+
+	/* Drop shutdown before the check */
+	*shutdown = 0;
+
+	rc = poll(pfd, 1, 10);
+	if (rc < 0) {
+		*shutdown = -errno;
+		return false;
+	}
+	bool ret = ((rc == 1) && (pfd[0].revents & POLLIN));
+	if (!ret && (pfd[0].revents & (POLLERR | POLLHUP | POLLNVAL))) {
+		if (pfd[0].revents & (POLLERR | POLLNVAL)) {
+			*shutdown = -EBADF;
+		} else {
+			/* POLLHUP - normal connection close */
+			*shutdown = 1;
+		}
+	}
+	return ret;
+}
+
+bool pmixp_fd_write_ready(int fd, int *shutdown)
+{
+	struct pollfd pfd[1];
+	int rc;
+	pfd[0].fd = fd;
+	pfd[0].events = POLLOUT;
+	rc = poll(pfd, 1, 10);
+	if (rc < 0) {
+		*shutdown = -errno;
+		return false;
+	}
+	if (pfd[0].revents & (POLLERR | POLLHUP | POLLNVAL)) {
+		if (pfd[0].revents & (POLLERR | POLLNVAL)) {
+			*shutdown = -EBADF;
+		} else {
+			/* POLLHUP - normal connection close */
+			*shutdown = 1;
+		}
+	}
+	return ((rc == 1) && (pfd[0].revents & POLLOUT));
+}
+
+static int _send_to_stepds(hostlist_t hl, const char *addr, uint32_t len,
+		char *data)
+{
+	List ret_list = NULL;
+	int temp_rc = 0, rc = 0;
+	ret_data_info_t *ret_data_info = NULL;
+	slurm_msg_t *msg = xmalloc(sizeof(slurm_msg_t));
+	forward_data_msg_t req;
+	char *nodelist = NULL;
+
+	slurm_msg_t_init(msg);
+	req.address = xstrdup(addr);
+	req.len = len;
+	req.data = data;
+
+	msg->msg_type = REQUEST_FORWARD_DATA;
+	msg->data = &req;
+
+	nodelist = hostlist_ranged_string_xmalloc(hl);
+
+	if ((ret_list = slurm_send_recv_msgs(nodelist, msg, 0, false))) {
+		while ((ret_data_info = list_pop(ret_list))) {
+			temp_rc = slurm_get_return_code(ret_data_info->type,
+					ret_data_info->data);
+			if (temp_rc) {
+				rc = temp_rc;
+			} else {
+				hostlist_delete_host(hl,
+						ret_data_info->node_name);
+			}
+		}
+	} else {
+		error("tree_msg_to_stepds: no list was returned");
+		rc = SLURM_ERROR;
+	}
+
+	slurm_free_msg(msg);
+	xfree(nodelist);
+	xfree(req.address);
+	return rc;
+}
+
+int pmixp_stepd_send(char *nodelist, const char *address, char *data,
+		uint32_t len)
+{
+
+	int retry = 0, rc;
+	unsigned int delay = 100; /* in milliseconds */
+	hostlist_t hl;
+
+	hl = hostlist_create(nodelist);
+	while (1) {
+		if (retry == 1) {
+			PMIXP_ERROR("send failed, rc=%d, retrying", rc);
+		}
+
+		rc = _send_to_stepds(hl, address, len, data);
+
+		if (rc == SLURM_SUCCESS)
+			break;
+		retry++;
+		if (retry >= PMIXP_MAX_RETRY)
+			break;
+		/* wait with constantly increasing delay */
+		struct timespec ts =
+			{(delay / 1000), ((delay % 1000) * 1000000)};
+		nanosleep(&ts, NULL);
+		delay *= 2;
+	}
+	hostlist_destroy(hl);
+	return rc;
+}
+
+static int _is_dir(char *path)
+{
+	struct stat stat_buf;
+	int rc;
+	if (0 > (rc = stat(path, &stat_buf))) {
+		PMIXP_ERROR_STD("Cannot stat() path=\"%s\"", path);
+		return rc;
+	} else if (!S_ISDIR(stat_buf.st_mode)) {
+		return 0;
+	}
+	return 1;
+}
+
+int pmixp_rmdir_recursively(char *path)
+{
+	char nested_path[PATH_MAX];
+	DIR *dp;
+	struct dirent *ent;
+
+	int rc;
+
+	/*
+	 * Make sure that "directory" exists and is a directory.
+	 */
+	if (1 != (rc = _is_dir(path))) {
+		PMIXP_ERROR("path=\"%s\" is not a directory", path);
+		return (rc == 0) ? -1 : rc;
+	}
+
+	if ((dp = opendir(path)) == NULL) {
+		PMIXP_ERROR_STD("cannot open path=\"%s\"", path);
+		return -1;
+	}
+
+	while ((ent = readdir(dp)) != NULL) {
+		if (0 == strcmp(ent->d_name, ".")
+				|| 0 == strcmp(ent->d_name, "..")) {
+			/* skip special dir's */
+			continue;
+		}
+		snprintf(nested_path, sizeof(nested_path), "%s/%s", path,
+				ent->d_name);
+		if (_is_dir(nested_path)) {
+			pmixp_rmdir_recursively(nested_path);
+		} else {
+			unlink(nested_path);
+		}
+	}
+	closedir(dp);
+	if ((rc = rmdir(path))) {
+		PMIXP_ERROR_STD("Cannot remove path=\"%s\"", path);
+	}
+	return rc;
+}
diff --git a/src/plugins/mpi/pmix/pmixp_utils.h b/src/plugins/mpi/pmix/pmixp_utils.h
new file mode 100644
index 0000000..559e159
--- /dev/null
+++ b/src/plugins/mpi/pmix/pmixp_utils.h
@@ -0,0 +1,57 @@
+/*****************************************************************************\
+ **	pmix_utils.c - Various PMIx utility functions
+ *****************************************************************************
+ *  Copyright (C) 2014-2015 Artem Polyakov. All rights reserved.
+ *  Copyright (C) 2015      Mellanox Technologies. All rights reserved.
+ *  Written by Artem Polyakov <artpol84@gmail.com, artemp@mellanox.com>.
+ *
+ *  This file is part of SLURM, a resource management program.
+ *  For details, see <http://slurm.schedmd.com/>.
+ *  Please also read the included file: DISCLAIMER.
+ *
+ *  SLURM is free software; you can redistribute it and/or modify it under
+ *  the terms of the GNU General Public License as published by the Free
+ *  Software Foundation; either version 2 of the License, or (at your option)
+ *  any later version.
+ *
+ *  In addition, as a special exception, the copyright holders give permission
+ *  to link the code of portions of this program with the OpenSSL library under
+ *  certain conditions as described in each individual source file, and
+ *  distribute linked combinations including the two. You must obey the GNU
+ *  General Public License in all respects for all of the code used other than
+ *  OpenSSL. If you modify file(s) with this exception, you may extend this
+ *  exception to your version of the file(s), but you are not obligated to do
+ *  so. If you do not wish to do so, delete this exception statement from your
+ *  version.  If you delete this exception statement from all source files in
+ *  the program, then also delete it here.
+ *
+ *  SLURM is distributed in the hope that it will be useful, but WITHOUT ANY
+ *  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+ *  FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
+ *  details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with SLURM; if not, write to the Free Software Foundation, Inc.,
+ *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA.
+ \*****************************************************************************/
+
+#ifndef PMIXP_UTILS_H
+#define PMIXP_UTILS_H
+
+#include "pmixp_common.h"
+
+void pmixp_xfree_xmalloced(void *x);
+void pmixp_free_Buf(void *x);
+int pmixp_usock_create_srv(char *path);
+size_t pmixp_read_buf(int fd, void *buf, size_t count, int *shutdown,
+		bool blocking);
+size_t pmixp_write_buf(int fd, void *buf, size_t count, int *shutdown,
+		bool blocking);
+bool pmixp_fd_read_ready(int fd, int *shutdown);
+bool pmixp_fd_write_ready(int fd, int *shutdown);
+int pmixp_srun_send(slurm_addr_t *addr, uint32_t len, char *data);
+int pmixp_stepd_send(char *nodelist, const char *address, char *data,
+		uint32_t len);
+int pmixp_rmdir_recursively(char *path);
+
+#endif /* PMIXP_UTILS_H*/
diff --git a/src/plugins/mpi/pmix/tests/pmix_client.c b/src/plugins/mpi/pmix/tests/pmix_client.c
new file mode 100644
index 0000000..07b56a6
--- /dev/null
+++ b/src/plugins/mpi/pmix/tests/pmix_client.c
@@ -0,0 +1,368 @@
+/*
+ * Copyright (c) 2004-2010 The Trustees of Indiana University and Indiana
+ *                         University Research and Technology
+ *                         Corporation.  All rights reserved.
+ * Copyright (c) 2004-2011 The University of Tennessee and The University
+ *                         of Tennessee Research Foundation.  All rights
+ *                         reserved.
+ * Copyright (c) 2004-2005 High Performance Computing Center Stuttgart,
+ *                         University of Stuttgart.  All rights reserved.
+ * Copyright (c) 2004-2005 The Regents of the University of California.
+ *                         All rights reserved.
+ * Copyright (c) 2006-2013 Los Alamos National Security, LLC.
+ *                         All rights reserved.
+ * Copyright (c) 2009-2012 Cisco Systems, Inc.  All rights reserved.
+ * Copyright (c) 2011      Oak Ridge National Labs.  All rights reserved.
+ * Copyright (c) 2013-2014 Intel, Inc.  All rights reserved.
+ * Copyright (c) 2015      Mellanox Technologies, Inc.  All rights reserved.
+ * $COPYRIGHT$
+ *
+ * Additional copyrights may follow
+ *
+ * $HEADER$
+ *
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <time.h>
+
+#include <pmix.h>
+#include "test_common.h"
+
+#define true 1
+#define false 0
+
+int get_local_peers(int **_peers)
+{
+	pmix_value_t *val;
+	int *peers = NULL;
+	char *sptr, *token, *eptr, *str;
+	int npeers;
+	char nspace[PMIX_MAX_VALLEN];
+	int rank, count, rc;
+
+	/* To get namespace and rank */
+	if (PMIX_SUCCESS != (rc = PMIx_Init(nspace, &rank))) {
+		TEST_ERROR(("rank %d: PMIx_Init failed: %d", rank, rc));
+		exit(0);
+	}
+	//* to keep reference counter consistent */
+	PMIx_Finalize();
+
+	/* get number of neighbours on this node */
+	if (PMIX_SUCCESS != (rc = PMIx_Get(nspace, rank, PMIX_LOCAL_SIZE, &val))) {
+		TEST_ERROR(("rank %d: PMIx_Get local peer # failed: %d", rank, rc));
+		exit(0);
+	}
+	if (NULL == val) {
+		TEST_ERROR(("rank %d: PMIx_Get local peer # returned NULL value", rank));
+		exit(0);
+	}
+
+	if (val->type != PMIX_UINT32 ) {
+		TEST_ERROR(("rank %d: local peer # attribute value type mismatch,"
+			    " want %d get %d(%d)",
+			    rank, PMIX_UINT32, val->type));
+		exit(0);
+	}
+	npeers = val->data.uint32;
+	peers = malloc(sizeof(int) * npeers);
+
+	/* get ranks of neighbours on this node */
+	if (PMIX_SUCCESS != (rc = PMIx_Get(nspace, rank, PMIX_LOCAL_PEERS, &val))) {
+		TEST_ERROR(("rank %d: PMIx_Get local peers failed: %d", rank, rc));
+		exit(0);
+	}
+	if (NULL == val) {
+		TEST_ERROR(("rank %d: PMIx_Get local peers returned NULL value", rank));
+		exit(0);
+	}
+
+	if (val->type != PMIX_STRING ) {
+		TEST_ERROR(("rank %d: local peers attribute value type mismatch,"
+			    " want %d get %d(%d)",
+			    rank, PMIX_UINT32, val->type));
+		exit(0);
+	}
+
+	count = 0;
+	sptr = NULL;
+	str = val->data.string;
+	do{
+		if (count > npeers) {
+			TEST_ERROR(("rank %d: Bad peer ranks number: should be %d, actual %d (%s)",
+			    rank, npeers, count, val->data.string));
+			exit(0);
+		}
+		token = strtok_r(str, ",", &sptr);
+		str = NULL;
+		if (NULL != token) {
+			peers[count++] = strtol(token,&eptr,10);
+			if (*eptr != '\0') {
+				TEST_ERROR(("rank %d: Bad peer ranks string", rank));
+				exit(0);
+			}
+		}
+
+	} while(NULL != token);
+
+	if (count != npeers) {
+		TEST_ERROR(("rank %d: Bad peer ranks number: should be %d, actual %d (%s)",
+			    rank, npeers, count, val->data.string));
+		exit(0);
+	}
+
+	*_peers = peers;
+	return count;
+}
+
+void release_cb(pmix_status_t status, void *cbdata)
+{
+	int *ptr = (int*)cbdata;
+	*ptr = 0;
+}
+
+int main(int argc, char **argv)
+{
+	char nspace[PMIX_MAX_VALLEN];
+	int rank;
+	int rc, i, j;
+	pmix_value_t value;
+	char key[50], sval[50];
+	int nprocs = 1;
+	int collect = false;
+	int nonblocking = false;
+	pmix_value_t *val = &value;
+	int *peers, npeers;
+
+	TEST_OUTPUT(("rank X: Start", rank));
+
+	//    system("set");
+
+	/* check options */
+	for (i=1; i < argc; i++) {
+		if (0 == strcmp(argv[i], "--n") || 0 == strcmp(argv[i], "-n")) {
+			i++;
+			nprocs = strtol(argv[i], NULL, 10);
+		} else if (0 == strcmp(argv[i], "collect")) {
+			collect = true;
+		} else if (0 == strcmp(argv[i], "nb")) {
+			nonblocking = true;
+		} else if ((0 == strcmp(argv[i], "-v")) || (0 == strcmp(argv[i], "--verbose"))) {
+			TEST_VERBOSE_ON();
+		}else {
+			fprintf(stderr, "unrecognized option: %s\n", argv[i]);
+			exit(1);
+		}
+	}
+
+	TEST_OUTPUT(("rank X: parsed command line", rank));
+
+	{
+		int delay = 0;
+		while(delay) {
+			sleep(1);
+		}
+	}
+
+	/* init us */
+	if (PMIX_SUCCESS != (rc = PMIx_Init(nspace, &rank))) {
+		TEST_ERROR(("rank %d: PMIx_Init failed: %d", rank, rc));
+		exit(0);
+	}
+
+	TEST_OUTPUT(("rank %d: PMIx_Init success", rank));
+
+	if (PMIX_SUCCESS != (rc = PMIx_Get(nspace, rank,PMIX_UNIV_SIZE,&val))) {
+		TEST_ERROR(("rank %d: PMIx_Get universe size failed: %d", rank, rc));
+		exit(0);
+	}
+	if (NULL == val) {
+		TEST_ERROR(("rank %d: PMIx_Get universe size returned NULL value", rank));
+		exit(0);
+	}
+	/* TODO: Guess number of processes from the SLURM environment! */
+	if (val->type != PMIX_UINT32 || val->data.uint32 != nprocs) {
+		TEST_ERROR(("rank %d: Universe size value or type mismatch,"
+			    " want %d(%d) get %d(%d)",
+			    rank, nprocs, PMIX_UINT32,
+			    val->data.integer, val->type));
+		exit(0);
+	}
+	TEST_OUTPUT(("rank %d: Universe size check: PASSED", rank));
+
+	/* Guess the namespace from SLURM environment
+    if (0 != strcmp(nspace, TEST_NAMESPACE)) {
+	TEST_ERROR(("rank %d: Bad nspace!", rank));
+	exit(0);
+    }
+*/
+
+	for (i=0; i < 3; i++) {
+		(void)snprintf(key, 50, "local-key-%d", i);
+		PMIX_VAL_SET(&value, int, 12340 + i);
+		if (PMIX_SUCCESS != (rc = PMIx_Put(PMIX_LOCAL, key, &value))) {
+			TEST_ERROR(("rank %d: PMIx_Put failed: %d", rank, rc));
+			exit(0);
+		}
+
+		(void)snprintf(key, 50, "remote-key-%d", i);
+		(void)snprintf(sval, 50, "Test string #%d", i);
+		PMIX_VAL_SET(&value, string, sval);
+		if (PMIX_SUCCESS != (rc = PMIx_Put(PMIX_REMOTE, key, &value))) {
+			TEST_ERROR(("rank %d: PMIx_Put failed: %d", rank, rc));
+			exit(0);
+		}
+		PMIX_VALUE_DESTRUCT(&value);
+
+		(void)snprintf(key, 50, "global-key-%d", i);
+		PMIX_VAL_SET(&value, float, 12.15 + i);
+		if (PMIX_SUCCESS != (rc = PMIx_Put(PMIX_GLOBAL, key, &value))) {
+			TEST_ERROR(("rank %d: PMIx_Put failed: %d", rank, rc));
+			exit(0);
+		}
+	}
+
+	/* Submit the data */
+	if (PMIX_SUCCESS != (rc = PMIx_Commit())) {
+	    TEST_ERROR(("rank %d: PMIx_Commit failed: %d", rank, rc));
+	    goto error_out;
+	}
+
+	/* Perform a fence if was requested */
+	if (!nonblocking) {
+		if (PMIX_SUCCESS != (rc = PMIx_Fence(NULL, 0, 1))) {
+			TEST_ERROR(("rank %d: PMIx_Fence failed: %d", rank, rc));
+			exit(0);
+		}
+	} else {
+		int in_progress = 1, count;
+		if (PMIX_SUCCESS != (rc = PMIx_Fence_nb(NULL, 0, collect, release_cb, &in_progress))) {
+			TEST_ERROR(("rank %d: PMIx_Fence failed: %d", rank, rc));
+			exit(0);
+		}
+
+		count = 0;
+		while(in_progress) {
+			struct timespec ts;
+			ts.tv_sec = 0;
+			ts.tv_nsec = 100;
+			nanosleep(&ts,NULL);
+			count++;
+
+		}
+		TEST_OUTPUT(("PMIx_Fence_nb(barrier,collect): free time: %lfs", count*100*1E-9));
+	}
+	TEST_OUTPUT(("rank %d: Fence successfully completed", rank));
+
+	npeers = get_local_peers(&peers);
+
+//{
+//    int delay = 1;
+//    while(delay) {
+//	sleep(1);
+//    }
+//}
+	/* Check the predefined output */
+	for (i=0; i < nprocs; i++) {
+
+		for (j=0; j < 3; j++) {
+			int local = 0, k;
+			for(k=0; k<npeers; k++) {
+				if (peers[k] == i) {
+					local = 1;
+				}
+			}
+
+			if (local) {
+				sprintf(key,"local-key-%d",j);
+				if (PMIX_SUCCESS != (rc = PMIx_Get(nspace, i, key, &val))) {
+					TEST_ERROR(("rank %d: PMIx_Get failed: %d", rank, rc));
+					exit(0);
+				}
+				if (NULL == val) {
+					TEST_ERROR(("rank %d: PMIx_Get returned NULL value", rank));
+					exit(0);
+				}
+				if (val->type != PMIX_INT || val->data.integer != (12340+j)) {
+					TEST_ERROR(("rank %d: Key %s value or type mismatch,"
+						    " want %d(%d) get %d(%d)",
+						    rank, key, (12340+j), PMIX_INT,
+						    val->data.integer, val->type));
+					exit(0);
+				}
+				TEST_VERBOSE(("rank %d: GET OF %s SUCCEEDED", rank, key));
+				PMIX_VALUE_RELEASE(val);
+			}
+			sprintf(key,"remote-key-%d",j);
+			sprintf(sval,"Test string #%d",j);
+			if (PMIX_SUCCESS != (rc = PMIx_Get(nspace, i, key, &val))) {
+				TEST_ERROR(("rank %d: PMIx_Get failed (%d)", rank, rc));
+				exit(0);
+			}
+			if (val->type != PMIX_STRING || strcmp(val->data.string, sval)) {
+				TEST_ERROR(("rank %d:  Key %s value or type mismatch, wait %s(%d) get %s(%d)",
+					    rank, key, sval, PMIX_STRING, val->data.string, val->type));
+				exit(0);
+			}
+			TEST_VERBOSE(("rank %d: GET OF %s SUCCEEDED", rank, key));
+			PMIX_VALUE_RELEASE(val);
+
+			sprintf(key, "global-key-%d", j);
+			if (PMIX_SUCCESS != (rc = PMIx_Get(nspace, i, key, &val))) {
+				TEST_ERROR(("rank %d: PMIx_Get failed (%d)", rank, rc))
+						exit(0);
+			}
+			if (val->type != PMIX_FLOAT || val->data.fval != (float)12.15 + j) {
+				TEST_ERROR(("rank %d [ERROR]: Key %s value or type mismatch,"
+					    " wait %f(%d) get %f(%d)",
+					    rank, key, ((float)10.15 + i), PMIX_FLOAT,
+					    val->data.fval, val->type));
+				exit(0);
+			}
+			PMIX_VALUE_RELEASE(val);
+			TEST_VERBOSE(("rank %d: GET OF %s SUCCEEDED", rank, key));
+		}
+
+		/* ask for a non-existent key */
+		if (PMIX_SUCCESS == (rc = PMIx_Get(nspace, i, "foobar", &val))) {
+			TEST_ERROR(("rank %d: PMIx_Get returned success instead of failure",
+				    rank));
+			exit(0);
+		}
+		if (PMIX_ERR_NOT_FOUND != rc) {
+			TEST_ERROR(("rank %d [ERROR]: PMIx_Get returned %d instead of not_found",
+				    rank, rc));
+		}
+		if (NULL != val) {
+			TEST_ERROR(("rank %d [ERROR]: PMIx_Get did not return NULL value", rank));
+			exit(0);
+		}
+		TEST_VERBOSE(("rank %d: rank %d is OK", rank, i));
+	}
+
+	TEST_OUTPUT(("rank %d: test PASSED", rank));
+
+error_out:
+	/* finalize us */
+	TEST_OUTPUT(("rank %d: Finalizing", rank));
+	fflush(stderr);
+	/*
+    {
+	int delay = 1;
+	while(delay) {
+	    sleep(1);
+	}
+    }
+*/
+
+	if (PMIX_SUCCESS != (rc = PMIx_Finalize())) {
+		TEST_ERROR(("rank %d:PMIx_Finalize failed: %d", rank, rc));
+	} else {
+		TEST_OUTPUT(("rank %d:PMIx_Finalize successfully completed", rank));
+	}
+
+	exit(0);
+}
diff --git a/src/plugins/mpi/pmix/tests/test_common.c b/src/plugins/mpi/pmix/tests/test_common.c
new file mode 100644
index 0000000..353dbde
--- /dev/null
+++ b/src/plugins/mpi/pmix/tests/test_common.c
@@ -0,0 +1,15 @@
+#include "test_common.h"
+#include <stdarg.h>
+
+int pmix_test_verbose = 0;
+
+#define OUTPUT_MAX 1024
+char *pmix_test_output_prepare(const char *fmt, ...)
+{
+    static char output[OUTPUT_MAX];
+    va_list args;
+    va_start(args, fmt);
+    memset(output, 0, sizeof(output));
+    vsnprintf(output, OUTPUT_MAX - 1, fmt, args);
+    return output;
+}
diff --git a/src/plugins/mpi/pmix/tests/test_common.h b/src/plugins/mpi/pmix/tests/test_common.h
new file mode 100644
index 0000000..381091e
--- /dev/null
+++ b/src/plugins/mpi/pmix/tests/test_common.h
@@ -0,0 +1,51 @@
+/*
+ * Copyright (c) 2013-2015 Intel, Inc.  All rights reserved.
+ * Copyright (c) 2015      Artem Y. Polyakov <artpol84@gmail.com>.
+ *                         All rights reserved.
+ * $COPYRIGHT$
+ *
+ * Additional copyrights may follow
+ *
+ * $HEADER$
+ *
+ */
+
+#ifndef TEST_COMMON_H
+#define TEST_COMMON_H
+
+#include <stdio.h>
+#include <string.h>
+
+#define TEST_NAMESPACE "smoky_nspace"
+#define TEST_CREDENTIAL "dummy"
+
+/* WARNING: pmix_test_output_prepare is currently not threadsafe!
+ * fix it once needed!
+ */
+char *pmix_test_output_prepare(const char *fmt,...);
+extern int pmix_test_verbose;
+
+#define STRIPPED_FILE_NAME (strrchr(__FILE__, '/') ? strrchr(__FILE__, '/') + 1 : __FILE__)
+
+#define TEST_OUTPUT(x) { \
+    fprintf(stderr,"%s:%s: %s\n",STRIPPED_FILE_NAME, __FUNCTION__, \
+            pmix_test_output_prepare x); \
+    fflush(stderr); \
+}
+
+#define TEST_ERROR(x) { \
+    fprintf(stderr,"ERROR [%s:%d:%s]: %s\n", STRIPPED_FILE_NAME, __LINE__, __FUNCTION__, \
+            pmix_test_output_prepare x); \
+    fflush(stderr); \
+}
+
+#define TEST_VERBOSE_ON() (pmix_test_verbose = 1)
+
+#define TEST_VERBOSE(x) { \
+    if (pmix_test_verbose) { \
+        TEST_OUTPUT(x); \
+    } \
+}
+
+
+#endif // TEST_COMMON_H
